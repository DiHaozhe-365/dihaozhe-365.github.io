<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编码规范八荣八耻</title>
    <url>/posts/d0000001.html</url>
    <content><![CDATA[<hr>
<h2 id="以接口兼容为荣，以接口裸奔为耻"><a href="#以接口兼容为荣，以接口裸奔为耻" class="headerlink" title="以接口兼容为荣，以接口裸奔为耻"></a>以<strong>接口兼容</strong>为荣，以<strong>接口裸奔</strong>为耻</h2><h2 id="以规范日志为荣，以乱打日志为耻"><a href="#以规范日志为荣，以乱打日志为耻" class="headerlink" title="以规范日志为荣，以乱打日志为耻"></a>以<strong>规范日志</strong>为荣，以<strong>乱打日志</strong>为耻</h2><h2 id="以代码自测为荣，以过度自信为耻"><a href="#以代码自测为荣，以过度自信为耻" class="headerlink" title="以代码自测为荣，以过度自信为耻"></a>以<strong>代码自测</strong>为荣，以<strong>过度自信</strong>为耻</h2><h2 id="以参数校验为荣，以运行异常为耻"><a href="#以参数校验为荣，以运行异常为耻" class="headerlink" title="以参数校验为荣，以运行异常为耻"></a>以<strong>参数校验</strong>为荣，以<strong>运行异常</strong>为耻</h2><h2 id="以设计模式为荣，以代码重复为耻"><a href="#以设计模式为荣，以代码重复为耻" class="headerlink" title="以设计模式为荣，以代码重复为耻"></a>以<strong>设计模式</strong>为荣，以<strong>代码重复</strong>为耻</h2><h2 id="以优化代码为荣，以复制粘贴为耻"><a href="#以优化代码为荣，以复制粘贴为耻" class="headerlink" title="以优化代码为荣，以复制粘贴为耻"></a>以<strong>优化代码</strong>为荣，以<strong>复制粘贴</strong>为耻</h2><h2 id="以定义常量为荣，以魔法数字为耻"><a href="#以定义常量为荣，以魔法数字为耻" class="headerlink" title="以定义常量为荣，以魔法数字为耻"></a>以<strong>定义常量</strong>为荣，以<strong>魔法数字</strong>为耻</h2><h2 id="以总结思考为荣，以浑水摸鱼为耻"><a href="#以总结思考为荣，以浑水摸鱼为耻" class="headerlink" title="以总结思考为荣，以浑水摸鱼为耻"></a>以<strong>总结思考</strong>为荣，以<strong>浑水摸鱼</strong>为耻</h2><hr>
]]></content>
      <categories>
        <category>博客站务</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>《算法设计与分析》</title>
    <url>/posts/a0060000.html</url>
    <content><![CDATA[<h2 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h2><h3 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章 概论"></a><a href="https://georgedi.top/posts/a0060001.html">第1章 概论</a></h3><h3 id="第2章-递归算法设计技术"><a href="#第2章-递归算法设计技术" class="headerlink" title="第2章 递归算法设计技术"></a><a href="https://georgedi.top/posts/a0060002.html">第2章 递归算法设计技术</a></h3><h3 id="第3章-分治法"><a href="#第3章-分治法" class="headerlink" title="第3章 分治法"></a><a href="https://georgedi.top/posts/a0060003.html">第3章 分治法</a></h3><h3 id="第5章-回溯法"><a href="#第5章-回溯法" class="headerlink" title="第5章 回溯法"></a><a href="https://georgedi.top/posts/a0060005.html">第5章 回溯法</a></h3><h3 id="第7章-贪心法"><a href="#第7章-贪心法" class="headerlink" title="第7章 贪心法"></a><a href="https://georgedi.top/posts/a0060007.html">第7章 贪心法</a></h3><h3 id="第8章-动态规划"><a href="#第8章-动态规划" class="headerlink" title="第8章 动态规划"></a><a href="https://georgedi.top/posts/a0060008.html">第8章 动态规划</a></h3>]]></content>
      <categories>
        <category>科班基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 概论</title>
    <url>/posts/a0060001.html</url>
    <content><![CDATA[<h2 id="1-1-算法的概念"><a href="#1-1-算法的概念" class="headerlink" title="1.1 算法的概念"></a>1.1 算法的概念</h2><h3 id="1-1-1-什么是算法"><a href="#1-1-1-什么是算法" class="headerlink" title="1.1.1 什么是算法"></a>1.1.1 什么是算法</h3><p>算法（ algorithm ）是<strong>求解问题的一系列计算步骤</strong>，用来将<strong>输入数据</strong>转换成<strong>输出结果</strong>。</p>
<p>如果一个算法对其每一个输入实例都能输出正确的结果并停止，则称它是正确的。一个正确的算法解决了给定的求解问题，不正确的算法对于某些输入来说可能根本不会停止，或者停止时给出的不是预期的结果。</p>
<p>算法设计应满足以下几个目标：</p>
<ol>
<li><strong>正确性</strong>：要求算法能够正确地执行预先规定的功能和性能要求。这是最重要也是最基本的标准。</li>
<li><strong>可使用性</strong>：要求算法能够很方便地使用。这个特性也叫作用户友好性。</li>
<li><strong>可读性</strong>：算法应该易于人的理解，也就是可读性好。为了达到这个要求，算法的逻辑必须是清晰的、简单的和结构化的。</li>
<li><strong>健壮性</strong>：要求算法具有很好的容错性，即提供异常处理，能够对不合理的数据进行检查，不经常出现异常中断或死机现象。</li>
<li><strong>高效率与低存储量需求</strong>：通常，算法的效率主要指算法的执行时间。对于同一个问题如果有多种算法可以求解，执行时间短的算法效率高。算法存储量指的是算法执行过程中所需的最大存储空间。效率和低存储量都与问题的规模有关。</li>
</ol>
<p>算法具有以下 5 个重要特性：</p>
<ol>
<li><strong>有限性</strong>：一个算法必须总是（对任何合法的输入值）在执行有限步之后结束，且每一步都可在有限时间内完成。</li>
<li><strong>确定性</strong>：算法中的每一条指令必须有确切的含义，不会产生二义性。</li>
<li><strong>可行性</strong>：算法中的每一条运算都必须是足够基本的，也就是说它们在原则上都能精确地执行，甚至人们仅用笔和纸做有限次运算就能完成。</li>
<li><strong>输入性</strong>：一个算法有零个或多个输入。大多数算法的输入参数是必要的，但对于较简单的算法，如计算 1+2 的值，不需要任何输入参数，因此算法的输入可以是零个。</li>
<li><strong>输出性</strong>：一个算法有一个或多个输出。算法用于某种数据处理，如果没有输出，这样的算法是没有意义的，这些输出是和输入有着某些特定关系的量。</li>
</ol>
<h3 id="1-1-2-算法描述"><a href="#1-1-2-算法描述" class="headerlink" title="1.1.2 算法描述"></a>1.1.2 算法描述</h3><p>描述算法的方式很多，有的采用类 Pascal 语言，有的采用自然语言伪码。</p>
<p>本知识库采用 C&#x2F;C++ 语言描述算法的实现过程，通常用 C&#x2F;C++ 函数来描述算法。</p>
<p>以设计求 1+2+…+n 的值的算法为例说明 C&#x2F;C++ 语言描述算法的一般形式，该算法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//当参数错误时返回 false</span></span><br><span class="line">    s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        s+=i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//当参数正确并产生正确结果时返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常用函数的返回值表示算法能否正确执行，当算法只有一个返回值或者返回值可以区分算法是否正确执行时用函数返回值来表示算法的执行结果，另外还可以带有形参表示算法的输入&#x2F;输出。</p>
<p>任何算法（用函数描述）都是被调用的（在 C&#x2F;C++ 语言中除 main 函数外任何一个函数都会被其他函数调用，如果一个函数不被调用，这样的函数是没有意义的）。在 C 语言中调用函数时只有从实参到形参的单向值传递，在执行函数时若改变了形参，对应的实参不会同步改变。例如设计以下主函数调用上面的 fun 函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fun</span>(a,b)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;参数错误＼n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行时发现输出结果为 0，因为 b 对应的形参为 s，fun 执行后 s&#x3D;55，但 s 并没有回传给实参 b。在 C 语言中可以用传指针方式来实现形参的回传，但增加了函数的复杂性。为此在 C++ 语言中增加了引用型参数的概念，<strong>引用型参数名前需加上 &amp;，表示这样的形参在执行后会将结果回传给对应的实参。</strong></p>
<p>上例采用 C++ 语言描述算法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//当参数错误时返回 false</span></span><br><span class="line">    s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        s+=i;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">//当参数正确并产生正确结果时返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当将形参 s 改为引用类型的参数后，在执行时 main 函数的输出结果就正确了，即输出 55。</p>
<p>由于 C 语言不支持引用类型，C++ 语言支持引用类型，所以本知识库的算法描述语言为 C&#x2F;C++ 语言。需要注意的是，在 C&#x2F;C++ 语言中数组本身就是一种引用类型，所以当数组作为形参需要回传数据时其数组名之前不需要加 &amp;，它自动将形参数组的值回传给实参数组。</p>
<blockquote>
<p>在设计算法时，如果某个形参需要将执行结果回传给实参，则将该形参设计为引用型参数。带有引用型参数的程序不能在 Turbo C 中运行，可以在 BC++、Visual C++、Dev C++ 等编译环境中运行，通常程序文件扩展名为 .cpp 而不是 .c。</p>
</blockquote>
<h3 id="1-1-3-算法和数据结构"><a href="#1-1-3-算法和数据结构" class="headerlink" title="1.1.3 算法和数据结构"></a>1.1.3 算法和数据结构</h3><p>算法与数据结构既有联系又有区别。</p>
<p>数据结构是算法设计的基础。算法的操作对象是数据结构，在设计算法时通常要构建适合这种算法的数据结构。数据结构设计主要是选择数据的存储方式，例如确定求解问题中的数据采用数组存储还是采用链表存储等。算法设计就是在选定的存储结构上设计一个满足要求的好算法。</p>
<p>另外，数据结构关注的是数据的逻辑结构、存储结构以及基本操作，而算法更多的是关注如何在数据结构的基础上解决实际问题。算法是编程思想，数据结构则是这些思想的逻辑基础。</p>
<h3 id="1-1-4-算法设计的基本步骤"><a href="#1-1-4-算法设计的基本步骤" class="headerlink" title="1.1.4 算法设计的基本步骤"></a>1.1.4 算法设计的基本步骤</h3><p>算法是求解问题的解决方案，这个解决方案本身并不是问题的答案，而是能获得答案的指令序列，即算法，通过算法的执行获得求解问题的答案。</p>
<p>算法设计是一个灵活的充满智慧的过程，其基本步骤如下所示：</p>
<ol>
<li>分析求解问题：确定求解问题的目标（功能）、给定的条件（输入）和生成的结果（输出）。</li>
<li>选择数据结构和算法设计策略：设计数据对象的存储结构，因为算法的效率取决于数据对象的存储表示。算法设计有一些通用策略，例如迭代法、分治法、动态规划和回溯法等，需要针对求解问题选择合适的算法设计策略。</li>
<li>描述算法：在构思和设计好一个算法后必须清楚、准确地将所设计的求解步骤记录下来，即描述算法。</li>
<li>证明算法正确性：算法正确性证明与数学证明有类似之处，因此可以采用数学证明方法，但用纯数字方法证明算法的正确不仅耗时，而且对大型软件开发也不适用。一般而言，为所有算法都给出完全的数学证明并不现实，因此选择那些已知是正确的算法自然能大大减少出错的机会。</li>
<li>算法分析：同一问题的求解算法可能有多种，可以通过算法分析找到好的算法。一般来说，一个好的算法应该比同类算法的时间和空间效率高。</li>
</ol>
<h2 id="1-2-算法分析"><a href="#1-2-算法分析" class="headerlink" title="1.2 算法分析"></a>1.2 算法分析</h2><p>计算机资源主要包括计算时间和内存空间，算法分析是分析算法占用计算机资源的情况，所以算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度，其目的不是分析算法是否正确或是否容易阅读，主要是考察算法的时间和空间效率，以求改进算法或对不同的算法进行比较。</p>
<p>那么如何评价算法的效率呢？通常有两种衡量算法效率的方法：<strong>事后统计法</strong>和<strong>事前分析估算法</strong>。</p>
<p>前者存在这些缺点：一是必须执行程序，二是存在其他因素掩盖算法本质。</p>
<p>所以下面均采用事前分析估算法来分析算法效率。</p>
<p>分析算法占用计算机资源的情况，占用资源越多、算法复杂度越高，效率越低，反之占用的资源少、复杂度越低，效率越高。</p>
<p>衡量算法复杂性有2个维度：</p>
<ul>
<li>时间复杂度 𝑇(𝑛)：抽象计算机上运行所需时间。</li>
<li>空间复杂度 𝑆(𝑛) ：抽象计算机上运行所需空间。</li>
</ul>
<p>※𝑛：要解决的问题规模。</p>
<h3 id="1-2-1-算法时间复杂度分析"><a href="#1-2-1-算法时间复杂度分析" class="headerlink" title="1.2.1 算法时间复杂度分析"></a>1.2.1 算法时间复杂度分析</h3><h4 id="1-时间复杂度分析概述"><a href="#1-时间复杂度分析概述" class="headerlink" title="1.时间复杂度分析概述"></a>1.时间复杂度分析概述</h4><p>一个算法用高级语言实现后，在计算机上运行时所消耗的时间与很多因素有关，例如计算机的运行速度、编写程序采用的计算机语言、编译产生的机器语言代码质量和问题的规模等。</p>
<p>在这些因素中，前 3 个都与具体的机器有关。撇开这些与计算机硬件、软件有关的因素，仅考虑算法本身的效率高低，可以认为一个特定算法的“运行工作量”的大小只依赖于问题的规模（通常用整数量 n 表示），或者说它是问题规模的函数。这便是事前分析估算法。</p>
<p>算法的执行时间主要与<strong>问题规模</strong>有关，例如数组的元素个数、矩阵的阶数等都可作为问题规模。</p>
<p>算法执行时间是算法中所有语句的执行时间之和，显然与算法中所有语句的执行次数成正比。</p>
<p>为了客观地反映一个算法的执行时间，可以用算法中基本语句的执行次数来度量，算法中的<strong>基本语句</strong>是执行次数与整个算法的执行次数成正比的语句，它对算法执行时间的贡献最大，是算法中最重要的操作。</p>
<p>通常基本语句是算法中最深层循环内的语句。</p>
<p>采用渐进符号表示的算法时间复杂度也称为渐进时间复杂度，它反映的是一种增长趋势。</p>
<p>假设机器速度是每秒 10<sup>8</sup> 次基本运算，有阶分别为 n<sup>3</sup>、n<sup>2</sup>、nlog<sub>2</sub>n、n、2<sup>n</sup> 和 n! 的算法，在 1 秒之内能够解决的最大问题规模 n 如下所示：</p>
<table>
<thead>
<tr>
<th align="center">算法的阶</th>
<th align="center">n!</th>
<th align="center">2<sup>n</sup></th>
<th align="center">n<sup>3</sup></th>
<th align="center">n<sup>2</sup></th>
<th align="center">nlog<sub>2</sub>n</th>
<th align="center">n</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 秒解决的最大问题规模 n</td>
<td align="center">11</td>
<td align="center">26</td>
<td align="center">464</td>
<td align="center">10,000</td>
<td align="center">4.5×106</td>
<td align="center">100,000,000</td>
</tr>
<tr>
<td align="center">机器速度提高 2 倍后 1 秒解决的最大问题规模 n</td>
<td align="center">11</td>
<td align="center">27</td>
<td align="center">584</td>
<td align="center">14,142</td>
<td align="center">8.6×106</td>
<td align="center">200,000,000</td>
</tr>
</tbody></table>
<p>从中看出，阶为 n! 和 2<sup>n</sup> 的算法不仅解决的问题规模非常小，而且增长缓慢；执行速度最快的阶为 nlog<sub>2</sub>n 和 n 的算法不仅解决的问题规模大，而且增长快。</p>
<p>通常称渐进时间复杂度为多项式的算法为有效算法，而称 n! 或 2<sup>n</sup> 这样的低效算法为指数时间算法。</p>
<h4 id="2-渐进符号（-O、Ω-和-Θ）"><a href="#2-渐进符号（-O、Ω-和-Θ）" class="headerlink" title="2.渐进符号（ O、Ω 和 Θ）"></a>2.渐进符号（ O、Ω 和 Θ）</h4><ul>
<li><p><strong>定义 1（大 O 符号）</strong>：f(n)&#x3D;O(g(n))（读作“f(n) 是 g(n) 的大 O”），当且仅当存在正常量 c 和 n<sub>0</sub>，使当 n≥n<sub>0</sub> 时 f(n)≤cg(n)，即 <strong>g(n）为 f(n) 的上界</strong>。</p>
<p>大 O 符号用来描述增长率的上界，表示 f(n) 的增长最多像 g(n) 的增长那样快，也就是说当输入规模为 n 时算法消耗时间的最大值。</p>
<p>这个上界的阶越低，结果就越有价值。</p>
<p>当一个算法的时间用大 O 符号表示时，总是采用最有价值的 g(n) 表示，称之为“紧凑上界”或“紧确上界”。</p>
<p>说明：在算法分析中，大 O 符号的应用非常广泛。因为它简化了增长数量级上界的描述，甚至也适合一些无法进行精确分析的复杂算法。</p>
</li>
<li><p><strong>定义 2（大 Ω 符号）</strong>: f(n)&#x3D;Ω(g(n))（读作”f(n) 是 g(n) 的大 Ω”），当且仅当存在正常量 c 和 n<sub>0</sub>，使当 n≥n<sub>0</sub> 时 f(n)≥cg(n)，即 <strong>g(n) 为 f(n) 的下界</strong>。</p>
<p>大 Ω 符号用来描述增长率的下界，表示 f(n) 的增长最少像 g(n) 的增长那样快，也就是说，当输入规模为 n 时算法消耗时间的最小值。</p>
<p>与大 O 符号相反，这个下界的阶越高，结果就越有价值。</p>
</li>
<li><p><strong>定义 3（大 Θ 符号）</strong>：f(n)&#x3D;Θ(g(n))（读作”f(n) 是 g(n) 的大 Θ”），当且仅当存在正常量 c<sub>1</sub>、c<sub>2</sub> 和 n<sub>0</sub>，使当 n≥n<sub>0</sub> 时有 c<sub>1</sub>g(n)≤f(n)≤c<sub>2</sub>g(n)，即 <strong>g(n) 与 f(n) 的同阶</strong>。</p>
<p>大 Θ 符号比大 O 符号和大 Ω 符号都精确，f(n)&#x3D;O(g(n))，当且仅当 g(n) 既是 f(n) 的上界又是 f(n) 的下界。</p>
</li>
</ul>
<p>渐进符号具有以下特性：</p>
<ol>
<li><strong>传递性</strong></li>
<li><strong>自反性</strong></li>
<li><strong>对称性</strong></li>
<li><strong>算术运算</strong></li>
</ol>
<h4 id="3-算法的最好、最坏和平均情况"><a href="#3-算法的最好、最坏和平均情况" class="headerlink" title="3.算法的最好、最坏和平均情况"></a>3.算法的最好、最坏和平均情况</h4><ul>
<li><p><strong>定义 4</strong>：设一个算法的输入规模为 n，D<sub>n</sub> 是所有输入的集合，任一输入 I∈D<sub>n</sub>，P(I) 是 I 出现的概率，有 ΣP(I)&#x3D;1，T(I) 是算法在输入 I 下所执行的基本语句次数，则该算法的平均执行时间为 A(n)&#x3D;ΣP(I)*T(I)，也就是说算法的平均情况是指各种特定输入下的基本语句执行次数的带权平均值。</p>
<p>算法的最好情况为 G(n)&#x3D;MIN{T(I)}，是指算法在所有输入 I 下所执行基本语句的最少执行次数。</p>
<p>算法的最坏情况为 W(n)&#x3D;MAX{T(I)}，是指算法在所有输入 I 下所执行基本语句的最大执行次数。</p>
</li>
</ul>
<h3 id="1-2-2-算法空间复杂度分析"><a href="#1-2-2-算法空间复杂度分析" class="headerlink" title="1.2.2 算法空间复杂度分析"></a>1.2.2 算法空间复杂度分析</h3><p>一个算法的存储量包括形参所占空间和临时变量所占空间。在对算法进行存储空间分析时只考察临时变量所占空间。</p>
<p>若所需临时空间相对于输入数据量来说是常数，则称此算法为<strong>原地工作</strong>或<strong>就地工作</strong>算法。</p>
<p>若所需临时空间依赖于特定的输入，则通常按最坏情况来考虑。</p>
<h2 id="1-3-算法设计工具——STL"><a href="#1-3-算法设计工具——STL" class="headerlink" title="1.3 算法设计工具——STL"></a>1.3 算法设计工具——STL</h2><p>数据结构课程主要讲授一些常用的数据结构及其算法设计思想，对于计算机专业的学生，学习和掌握这些基本知识是十分必要的。另一方面，C++ 中已经实现了数据结构中的很多容器和算法，它们构成标准 C++ 库的子集，即标准模板类库（ Standard Template Library，STL ）。</p>
<p>STL 是一个功能强大的基于模板的容器库，通过直接使用这些现成的标准化组件可以大大提高算法设计的效率和可靠性。</p>
<blockquote>
<p>说明：对于算法设计者而言，最好遵循“尽可能使用 STL 而不自己实现”的原则。</p>
</blockquote>
<h3 id="1-3-1-STL-概述"><a href="#1-3-1-STL-概述" class="headerlink" title="1.3.1 STL 概述"></a>1.3.1 STL 概述</h3><p>STL 主要由 container（容器）、algorithm（算法）和 iterator（迭代器）三大部分构成，容器用于存放数据对象（元素），算法用于操作容器中的数据对象。</p>
<p>尽管各种容器的内部结构各异，但其外部给人的感觉通常是相似的，即将容器数据的操作设计成通用算法，也就是将算法和容器分离开来。算法和容器之间的中介就是迭代器。</p>
<p><strong>容器</strong>、<strong>算法</strong>和<strong>迭代器</strong>称为 STL 的三大件，它们之间的关系如下图所示：</p>
<img src="https://s1.ax1x.com/2023/06/04/pCCPy8A.jpg" alt="STL三大件" style="zoom:67%;" />

<h4 id="1-什么是-STL-容器"><a href="#1-什么是-STL-容器" class="headerlink" title="1.什么是 STL 容器"></a>1.什么是 STL 容器</h4><p>简单地说，一个 STL 容器就是一种数据结构，例如链表、栈和队列等，这些数据结构在 STL 中都已经实现好了，在算法设计中可以直接使用它们。</p>
<p>以下是常用的数据结构和相应的头文件：</p>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">说明</th>
<th align="center">实现头文件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">向量（ vector ）</td>
<td align="center">连续存储元素。底层数据结构为数组。支持快速随机访问。</td>
<td align="center">&lt; vector &gt;</td>
</tr>
<tr>
<td align="center">字符串（ string ）</td>
<td align="center">字符串处理容器。</td>
<td align="center">&lt; string &gt;</td>
</tr>
<tr>
<td align="center">双端队列（ deque ）</td>
<td align="center">连续存储的指向不同元素的指针所组成的数组。底层数据结构为一个中央控制器和多个缓冲区，支持首尾元素（中间不能）快速增删，也支持随机访问。</td>
<td align="center">&lt; deque &gt;</td>
</tr>
<tr>
<td align="center">链表（ list ）</td>
<td align="center">由结点组成的链表，每个结点包含着一个元素。底层数据结构为双向链表，支持结点的快速增删。</td>
<td align="center">&lt; list &gt;</td>
</tr>
<tr>
<td align="center">栈（ stack ）</td>
<td align="center">后进先出的序列。底层一般用 deque 或者 list 实现。</td>
<td align="center">&lt; stack &gt;</td>
</tr>
<tr>
<td align="center">队列（ queue ）</td>
<td align="center">先进先出的序列。底层一般用 deque 或者 list 实现。</td>
<td align="center">&lt; queue &gt;</td>
</tr>
<tr>
<td align="center">优先队列（ priority_queue ）</td>
<td align="center">元素的进出队顺序由某个谓词或者关系函数决定的一种队列。底层数据结构一般为 vector 或者 deque。</td>
<td align="center">&lt; queue &gt;</td>
</tr>
<tr>
<td align="center">集合（ set ）&#x2F;多重集合（ multiset ）</td>
<td align="center">由结点组成的红黑树，每个结点都包含着一个元素，set 中的所有元素有序但不重复，multiset 中的所有关键字有序但不重复。</td>
<td align="center">&lt; set &gt;</td>
</tr>
<tr>
<td align="center">映射（ map ）&#x2F;多重映射（ multimap ）</td>
<td align="center">由（关键字，值）对组成的集合，底层数据结构为红黑树，map 中的所有关键字有序但不重复，multimap 中的所有关键字有序但可以重复。</td>
<td align="center">&lt; map &gt;</td>
</tr>
</tbody></table>
<p>C++ 中引入了命名空间的概念，在不同命名空间中可以存在相同名字的标识符。STL 的 sort() 以及其标识符都封装在命名空间 std 中，使用 STL 时必须将下面语句插入到源代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br></pre></td></tr></table></figure>

<h4 id="2-什么是-STL-算法"><a href="#2-什么是-STL-算法" class="headerlink" title="2.什么是 STL 算法"></a>2.什么是 STL 算法</h4><p>STL 算法是用来操作容器中数据的模板函数。</p>
<p>STL 算法部分主要由头文件 &lt; algorithm &gt;、&lt; numeric &gt; 和 &lt; functional &gt; 组成。</p>
<ul>
<li>&lt; algorithm &gt; 是所有 STL 头文件中最大的一个，它由一大堆模板函数组成，功能范围涉及容器元素的比较、交换、查找、遍历、复制、修改、删除、排序和合并等操作。</li>
<li>&lt; numeric &gt; 的体积很小，只包括几个简单数学运算的模板函数。</li>
<li>&lt; functional &gt; 中定义了一些模板类，用于声明关系函数对象。</li>
</ul>
<h4 id="3-什么是-STL-迭代器"><a href="#3-什么是-STL-迭代器" class="headerlink" title="3.什么是 STL 迭代器"></a>3.什么是 STL 迭代器</h4><p>简单地说，STL 迭代器用于访问容器中的数据对象。每个容器都有自己的迭代器，只有容器自己知道如何访问自己的元素。</p>
<p>迭代器像 C&#x2F;C++ 中的指针，算法通过迭代器来定位和操作容器中的元素。</p>
<p>迭代器有各种不同的创建方法，程序可能把迭代器作为一个变量创建，一个 STL 容器类可能为了使用一个特定类型的数据而创建一个迭代器。作为指针，必须能够使用 * 操作符来获取数据值。</p>
<p>程序员可以使用相关运算符来操作迭代器。例如，++ 运算符用来递增迭代器，以访问容器中的下一个数据对象。如果迭代器到达了容器中的最后一个元素的后面，则迭代器变成一个特殊的值，就好像使用 NULL 或未初始化的指针一样。</p>
<p>常用的迭代器如下：</p>
<ul>
<li>iterator：指向容器中存放元素的迭代器，用于正向遍历容器中的元素。</li>
<li>const_iterator：指向容器中存放元素的常量迭代器，只能读取容器中的元素。</li>
<li>reverse_iterator：指向容器中存放元素的反向迭代器，用于反向遍历容器中的元素。</li>
<li>const_reverse_iterator：指向容器中存放元素的常量反向迭代器，只能读取容器中的元素。</li>
</ul>
<p>例如，以下语句定义一个存放 int 型整数的 vector 容器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myv;</span><br></pre></td></tr></table></figure>

<p>用户可以使用 vector 容器的成员函数 push_back() 在 myv 的末尾插入元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">myv.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">myv.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">myv.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这样 myv 中包含 3 个元素，依次是 1、2、3。如果要正向输出所有元素，可以使用正向迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it	<span class="comment">//定义正向迭代器 it</span></span><br><span class="line"><span class="keyword">for</span>(it=myv.<span class="built_in">begin</span>();it!=myv.<span class="built_in">end</span>();++it)	<span class="comment">//从头到尾遍历所有元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);	<span class="comment">//输出：1 2 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果要反向输出所有元素，可以使用反向迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::reverse_iterator rit	<span class="comment">//定义反向迭代器 rit</span></span><br><span class="line"><span class="keyword">for</span>(rit=myv.<span class="built_in">rbegin</span>();rit!=myv.<span class="built_in">rend</span>();++rit)	<span class="comment">//从尾到头遍历所有元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*rit);	<span class="comment">//输出：3 2 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-常用的-STL-容器"><a href="#1-3-2-常用的-STL-容器" class="headerlink" title="1.3.2 常用的 STL 容器"></a>1.3.2 常用的 STL 容器</h3><p>STL 容器很多，每一个容器就是一个类模板，大致分为<strong>顺序容器</strong>、<strong>适配器容器</strong>和<strong>关联容器</strong> 3 种类型。</p>
<h3 id="1-3-3-STL-在算法设计中的应用"><a href="#1-3-3-STL-在算法设计中的应用" class="headerlink" title="1.3.3 STL 在算法设计中的应用"></a>1.3.3 STL 在算法设计中的应用</h3><ol>
<li>存放主数据</li>
<li>存放临时数据</li>
<li>检测数据元素的唯一性</li>
<li>数据的排序</li>
<li>优先队列作为堆</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0060000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章 递归算法设计技术</title>
    <url>/posts/a0060002.html</url>
    <content><![CDATA[<h2 id="2-1-什么是递归"><a href="#2-1-什么是递归" class="headerlink" title="2.1 什么是递归"></a>2.1 什么是递归</h2><h3 id="2-1-1-递归的定义"><a href="#2-1-1-递归的定义" class="headerlink" title="2.1.1 递归的定义"></a>2.1.1 递归的定义</h3><p>在数学与计算机科学中，<strong>递归</strong>（ recursion ）是指在函数的定义中又调用函数自身的方法。</p>
<p>若 p 函数定义中调用 p 函数，称之为<strong>直接递归</strong>；若 p 函数定义中调用 q 函数，而 q 函数定义中又调用 p 函数，称之为<strong>间接递归</strong>。</p>
<p>任何间接递归都可以等价地转化为直接递归。</p>
<p>如果一个递归过程或递归函数中的递归调用语句是最后一条执行语句，则称这种递归调用为<strong>尾递归</strong>。</p>
<blockquote>
<p>递归既是一种奇妙的现象，又是一种思考问题的方法，通过递归可简化问题的定义和求解过程。</p>
<p>实际上在现实世界中递归无处不在，例如在人类的发展繁衍中，人之间的辈分就是一种递归，祖先的递归定义是 x 的父母是 x 的祖先， x 祖先的双亲同样是 x 的祖先。</p>
</blockquote>
<p>【例2.1】设计求 n!（ n 为正整数）的递归算法。</p>
<p>对应的递归函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">return</span> (<span class="built_in">fun</span>(n<span class="number">-1</span>)*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数 fun(n) 的求解过程中直接调用 fun(n-1)，所以它是一个直接递归函数；又由于递归调用是最后一条语句，所以它又属于尾递归。</p>
<p>递归算法通常把一个大的复杂问题层层转化为一个或多个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以描述出解题过程所需要的多次重复计算，大大减少了算法的代码量。</p>
<p>一般来说，能够用递归解决的问题应该满足以下 3 个条件：</p>
<ol>
<li>需要解决的问题可以转化为一个或多个子问题来求解，而这些子问题的求解方法与原问题完全相同，只是在数量规模上不同。</li>
<li>递归调用的次数必须是有限的。</li>
<li>必须有结束递归的条件来终止递归。</li>
</ol>
<h3 id="2-1-2-何时使用递归"><a href="#2-1-2-何时使用递归" class="headerlink" title="2.1.2 何时使用递归"></a>2.1.2 何时使用递归</h3><p>在以下 3 种情况下经常要用到递归的方法。</p>
<h4 id="1-定义是递归的"><a href="#1-定义是递归的" class="headerlink" title="1.定义是递归的"></a>1.定义是递归的</h4><p>有许多数学公式、数列和概念的定义是递归的，例如求 n! 和斐波那契（ Fibonacci ）数列等。</p>
<p>对于这些问题的求解过程，可以将其递归定义直接转化为对应的递归算法，例如求 n! 可以转化为【例2.1】的递归算法。</p>
<h4 id="2-数据结构是递归的"><a href="#2-数据结构是递归的" class="headerlink" title="2.数据结构是递归的"></a>2.数据结构是递归的</h4><p>算法是用于数据处理的，有些存储数据的数据结构是递归的，对于递归数据结构，采用递归的方法设计算法既方便又有效。</p>
<p>例如，单链表就是一种递归数据结构，其结点类型声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> </span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> * next;</span><br><span class="line">&#125; LinkNode;	<span class="comment">//单链表结点类型</span></span><br></pre></td></tr></table></figure>

<p>其中，结构体 Node 的声明中用到了它自身，即指针域 next 是一种指向自身类型的指针。</p>
<h4 id="3-问题的求解方法是递归的"><a href="#3-问题的求解方法是递归的" class="headerlink" title="3.问题的求解方法是递归的"></a>3.问题的求解方法是递归的</h4><p>有些问题的解法是递归的，典型的有梵塔问题求解。</p>
<p>该问题的描述是设有 3 个分别命名为 x、y 和 z 的塔座，在塔座 x 上有 n 个直径各不相同、从小到大依次编号为 1~n 的盘片，现要求将 x 塔座上的 n 个盘片移到塔座 z 上并仍按同样的顺序叠放。在盘片移动时必须遵守以下规则：每次只能移动一个盘片；盘片可以插在 x、y 和 z 中的任一塔座；任何时候都不能将一个较大的盘片放在较小的盘片上。</p>
<h3 id="2-1-3-递归模型"><a href="#2-1-3-递归模型" class="headerlink" title="2.1.3 递归模型"></a>2.1.3 递归模型</h3><p>一般地，一个递归模型由<strong>递归出口</strong>和<strong>递归体</strong>两部分组成，前者确定递归到何时结束，即指出明确的递归结束条件，后者确定递归求解时的递推关系。</p>
<h3 id="2-1-4-递归算法的执行过程"><a href="#2-1-4-递归算法的执行过程" class="headerlink" title="2.1.4 递归算法的执行过程"></a>2.1.4 递归算法的执行过程</h3><p>在执行递归函数时会直接调用自身，但如果仅有这种操作，将会出现由于无休止地调用而陷入死循环。因此，一个正确的递归函数虽然每次调用的是相同的代码，但它的参数、输入数据等均有变化，并且在正常情况下随着调用的不断深入必定会出现调用到某一层的函数时不再执行递归调用而终止函数的执行，即遇到递归出口。</p>
<p>递归函数可以看成是一种特殊的函数，递归函数调用是函数调用的一种特殊情况，即它是调用自身代码，因此也可以把每一次递归调用理解成调用自身代码的一个复制件。由于每次调用时它的参数和局部变量值均不相同，所以保证了各个复制件执行时的独立性。</p>
<p>但递归调用在内部实现时并不是每次调用真的复制一个函数复制件存放到内存中，而是采用代码共享的方式，也就是它们都是调用同一个函数的代码。为此系统设置了一个系统栈，为每一次调用开辟一组存储单元，用来存放本次调用的返回地址以及被中断的函数参数值（即一个栈帧，可以理解为一个栈元素），然后将其进入系统栈（栈元素进栈），再执行被调用函数代码。当被调用函数执行完毕后，对应的栈帧被弹出（栈元素出栈），返回计算后的函数值，控制转到相应的返回地址继续执行。显然当前正在执行的调用函数的栈帧总是处于系统栈的最顶端。</p>
<p>所以一个函数调用过程就是将数据（包括参数和返回值）和控制信息（返回地址等）从一个函数传递到另一个函数。另外，在执行被调函数的过程中还要为被调函数的局部变量分配空间，在函数返回时释放这些空间，这些工作都是由系统栈来完成的。</p>
<p>从以上过程可以得出：</p>
<ol>
<li>递归执行是通过系统栈实现的。</li>
<li>每递归调用一次就需将参数、局部变量和返回地址等作为一个栈元素进栈一次，最多的进栈元素个数称为递归深度，n 越大，递归深度越深。</li>
<li>每当遇到递归出口或本次递归调用执行完毕时需退栈一次，并恢复参数值等，当全部执行完毕时栈应该为空。</li>
</ol>
<h2 id="2-2-递归算法设计"><a href="#2-2-递归算法设计" class="headerlink" title="2.2 递归算法设计"></a>2.2 递归算法设计</h2><h3 id="2-2-1-递归与数学归纳法"><a href="#2-2-1-递归与数学归纳法" class="headerlink" title="2.2.1 递归与数学归纳法"></a>2.2.1 递归与数学归纳法</h3><p>递归是算法和程序设计的一种实现技术，数学归纳法是一种论证方法，数学归纳法是递归的<strong>理论基础</strong>。</p>
<h3 id="2-2-2-递归算法设计的一般步骤"><a href="#2-2-2-递归算法设计的一般步骤" class="headerlink" title="2.2.2 递归算法设计的一般步骤"></a>2.2.2 递归算法设计的一般步骤</h3><p>递归算法设计首先要提炼出递归模型，再转换成对应的程序设计语言。</p>
<p>提炼递归模型过程中最重要的是找递归体，即确定<strong>大问题</strong>和<strong>小问题</strong>的关系。</p>
<h3 id="2-2-3-递归数据结构及其递归算法设计"><a href="#2-2-3-递归数据结构及其递归算法设计" class="headerlink" title="2.2.3 递归数据结构及其递归算法设计"></a>2.2.3 递归数据结构及其递归算法设计</h3><p><strong>定义</strong>：采用递归方式定义的数据结构称为递归数据结构。在递归数据结构定义中包含的递归运算称为基本递归运算。</p>
<h2 id="2-3-递归算法设计示例"><a href="#2-3-递归算法设计示例" class="headerlink" title="2.3 递归算法设计示例"></a>2.3 递归算法设计示例</h2><p>本节通过几个典型示例介绍递归算法设计方法。</p>
<h3 id="2-3-1-简单选择排序和冒泡排序"><a href="#2-3-1-简单选择排序和冒泡排序" class="headerlink" title="2.3.1 简单选择排序和冒泡排序"></a>2.3.1 简单选择排序和冒泡排序</h3><p>【问题描述】对于给定的含有 n 个元素的数组 a，分别采用简单选择排序和冒泡排序方法按元素值递增排序。</p>
<p>简单选择排序和冒泡排序方法都是将 a[0..n-1] 分为有序区 a[0..i-1] 和无序区两个部分，有序区中的所有元素都不大于无序区中的元素，初始时有序区为空（即 i&#x3D;0 ）。经过 n-1 趟排序（ i&#x3D;1~n-2 ），每趟排序采用不同方式将无序区中的最小元素移动到无序区的开头，即 a[i] 处。</p>
<h4 id="1-简单选择排序"><a href="#1-简单选择排序" class="headerlink" title="1.简单选择排序"></a>1.简单选择排序</h4><p>简单选择排序采用简单比较方式在无序区中选择最小元素并放到开头处。</p>
<p>对应的完整求解程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span>	<span class="comment">//交换 x 和 y 值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>	<span class="comment">//输出 a 中的所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> i)</span>	<span class="comment">//递归的简单选择排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j,k;</span><br><span class="line">    <span class="keyword">if</span>(i==n<span class="number">-1</span>) <span class="keyword">return</span>;	<span class="comment">//满足递归出口条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k=i;	<span class="comment">//k 记录 a[i..n-1] 中最小元素的下标</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)	<span class="comment">//在 a[i..n-1] 中找最小元素</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[k])</span><br><span class="line">                k=j;</span><br><span class="line">        <span class="keyword">if</span>(k!=i)	<span class="comment">//若最小元素不是 a[i]</span></span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[k]);	<span class="comment">//a[i] 和 a[k] 交换</span></span><br><span class="line">        <span class="built_in">SelectSort</span>(a,n,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>); <span class="built_in">disp</span>(a,n);</span><br><span class="line">    <span class="built_in">SelectSort</span>(a,n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>); <span class="built_in">disp</span>(a,n);	<span class="comment">//输出：1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h4><p>冒泡排序采用交换方式将无序区中的最小元素放到开头处。</p>
<p>对应的完整求解程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span>	<span class="comment">//交换 x 和 y 值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>	<span class="comment">//输出 a 中的所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n,<span class="type">int</span> i)</span>	<span class="comment">//递归的冒泡排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">bool</span> exchange;</span><br><span class="line">    <span class="keyword">if</span>(i==n<span class="number">-1</span>) <span class="keyword">return</span>;	<span class="comment">//满足递归出口条件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        exchange=<span class="literal">false</span>;	<span class="comment">//置 exchange 为 false</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])	<span class="comment">//当相邻元素反序时</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(a[j],a[j<span class="number">-1</span>]);</span><br><span class="line">                exchange=<span class="literal">true</span>;	<span class="comment">//发生交换置 exchange 为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(exchange==<span class="literal">false</span>)	<span class="comment">//未发生交换时直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//发生交换时继续递归调用</span></span><br><span class="line">            <span class="built_in">BubbleSort</span>(a,n,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>); <span class="built_in">disp</span>(a,n);</span><br><span class="line">    <span class="built_in">SelectSort</span>(a,n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>); <span class="built_in">disp</span>(a,n);	<span class="comment">//输出：1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-递归小结"><a href="#2-4-递归小结" class="headerlink" title="2.4 递归小结"></a>2.4 递归小结</h2><ul>
<li><p><strong>优点</strong></p>
<p>结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序带来很大方便。</p>
</li>
<li><p><strong>缺点</strong></p>
<p>递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。</p>
</li>
<li><p><strong>解决方法</strong></p>
<p>在递归算法中消除递归调用，使其转化为非递归算法（递推）。</p>
</li>
</ul>
<hr>
<p><a href="https://georgedi.top/posts/a0060000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章 分治法</title>
    <url>/posts/a0060003.html</url>
    <content><![CDATA[<h2 id="3-1-分治法概述"><a href="#3-1-分治法概述" class="headerlink" title="3.1 分治法概述"></a>3.1 分治法概述</h2><h3 id="3-1-1-分治法的设计思想"><a href="#3-1-1-分治法的设计思想" class="headerlink" title="3.1.1 分治法的设计思想"></a>3.1.1 分治法的设计思想</h3><p>对于一个规模为 n 的问题，若该问题可以容易地解决（例如规模 n 较小）则直接解决，否则将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合成并得到原问题的解，这种算法设计策略叫<strong>分治法</strong>。</p>
<p>分治法所能解决的问题一般具有以下几个特征：</p>
<ol>
<li><strong>该问题的规模缩小到一定的程度就可以容易地解决。</strong></li>
<li><strong>该问题可以分解为若干个规模较小的相似问题。</strong></li>
<li><strong>利用该问题分解出的子问题的解可以合并为该问题的解。</strong></li>
<li><strong>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</strong></li>
</ol>
<h3 id="3-1-2-分治法的求解过程"><a href="#3-1-2-分治法的求解过程" class="headerlink" title="3.1.2 分治法的求解过程"></a>3.1.2 分治法的求解过程</h3><p>递归特别适合解决结构自相似的问题，所谓结构自相似，是指构成原问题的子问题与原问题在结构上相似，可以采用类似的方法解决。所以分治法通常采用递归算法设计技术，在每一层递归上都有 3 个步骤：</p>
<ol>
<li><strong>分解成若干个子问题</strong>：将原问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。</li>
<li><strong>求解子问题</strong>：若子问题规模较小，容易被解决，则直接求解，否则递归地求解各个子问题。</li>
<li><strong>合并子问题</strong>：将各个子问题地解合并为原问题的解。</li>
</ol>
<h2 id="3-2-求解排序问题"><a href="#3-2-求解排序问题" class="headerlink" title="3.2 求解排序问题"></a>3.2 求解排序问题</h2><p>对于给定的含有 n 个元素的数组 a，对其按元素值递增排序。</p>
<p><strong>快速排序</strong>和<strong>归并排序</strong>是典型的采用分治法进行排序的方法。</p>
<h3 id="3-2-1-快速排序"><a href="#3-2-1-快速排序" class="headerlink" title="3.2.1 快速排序"></a>3.2.1 快速排序</h3><p>快速排序的基本思想是在待排序的 n 个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终位置后，整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，所有大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间，这个过程称为划分。然后对两个子序列分别重复上述过程，直到每个子序列内只有一个元素或空为止。</p>
<p>这是一种二分法思想，每次将整个无序序列一分为二，归位一个元素，对两个子序列采用同样的方式进行排序，直到子序列的长度为 1 或 0 为止。</p>
<p>快速排序的分治策略如下。</p>
<ol>
<li>分解：将原序列 a[s..t] 分解成两个子序列 a[s..i-1] 和 a[i+1..t]，其中 i 为划分的基准位置，即将整个问题分解为两个子问题。</li>
<li>求解子问题：若子序列的长度为0或1，则它是有序的，直接返回；否则递归地求解各个子问题。</li>
<li>合并：由于整个序列存放在数组 a 中，排序过程是就地进行的，合并步骤不需要执行任何操作。</li>
</ol>
<p>实现快速排序的完整程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>	<span class="comment">//输出 a 中的所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> s,<span class="type">int</span> t)</span>	<span class="comment">//划分算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=s,j=t;</span><br><span class="line">    <span class="type">int</span> tmp=a[s];	<span class="comment">//用序列的第 1 个记录作为基准</span></span><br><span class="line">    <span class="keyword">while</span>(i!=j)	<span class="comment">//从序列两端交替向中间扫描，直到 i=j 为止</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;i&amp;&amp;a[j]&gt;=tmp)</span><br><span class="line">            j--;	<span class="comment">//从右向左扫描，找第 1 个关键字小于 tmp 的 a[j]</span></span><br><span class="line">        a[i]=a[j];	<span class="comment">//将 a[j] 前移到 a[i] 的位置</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;=tmp)</span><br><span class="line">            i++;	<span class="comment">//从左向右扫描，找第 1 个关键字大于 tmp 的 a[i]</span></span><br><span class="line">        a[j]=a[i];	<span class="comment">//将 a[i] 后移到 a[j] 的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    a[i]=tmp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> s,<span class="type">int</span> t)</span>	<span class="comment">//对 a[s..t] 元素序列进行递增排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&lt;t)	<span class="comment">//序列内至少存在两个元素的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="built_in">Partition</span>(a,s,t);</span><br><span class="line">        <span class="built_in">QuickSort</span>(a,s,i<span class="number">-1</span>);	<span class="comment">//对左子序列递归排序</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(a,i+<span class="number">1</span>,t);	<span class="comment">//对右子序列递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>); <span class="built_in">disp</span>(a,n);</span><br><span class="line">    <span class="built_in">QuickSort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>); <span class="built_in">disp</span>(a,n);	<span class="comment">//输出：1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【算法分析】快速排序的时间主要耗费在划分操作上，对长度为 n 的区间进行划分，共需 n-1 次关键字的比较，时间复杂度为 O(n)。</p>
<h3 id="3-2-2-归并排序"><a href="#3-2-2-归并排序" class="headerlink" title="3.2.2 归并排序"></a>3.2.2 归并排序</h3><p>归并排序的基本思想是首先将 a[O..n-1] 看成 n 个长度为 1 的有序表，将相邻的 k（ k≥2 ）个有序子表成对归并，得到 n&#x2F;k 个长度为 k 的有序子表；然后再将这些有序子表继续归并，得到 n&#x2F;k<sup>2</sup> 个长度为 k<sup>2</sup> 的有序子表，如此反复进行下去，最后得到一个长度为 n 的有序表。由于整个排序结果放在一个数组中，所以不需要特别地进行合并操作。</p>
<p>若 k&#x3D;2，即归并是在相邻的两个有序子表中进行的，称为<strong>二路归并排序</strong>。</p>
<p>若 k&gt;2，即归并操作在相邻的多个有序子表中进行，则叫<strong>多路归并排序</strong>。</p>
<p>这里仅讨论二路归并排序算法。</p>
<p>二路归并排序算法主要有两种，下面一一讨论。</p>
<h4 id="1-自底向上的二路归并排序算法"><a href="#1-自底向上的二路归并排序算法" class="headerlink" title="1.自底向上的二路归并排序算法"></a>1.自底向上的二路归并排序算法</h4><p>实现自底向上的二路归并排序的完整程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>	<span class="comment">//输出 a 中的所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将 2 个相邻有序子序列归并为一个有序子序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* tmpa;</span><br><span class="line">    <span class="type">int</span> i=low,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    tmpa=(<span class="type">int</span>*)<span class="built_in">malloc</span>((high-low+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])	<span class="comment">//将第 1 子序列中的元素放入 tmpa 中</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpa[k]=a[i];</span><br><span class="line">            i++;k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//将第 2 子序列中的元素放入 tmpa 中</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpa[k]=a[j];</span><br><span class="line">            j++;k++;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)	<span class="comment">//将第 1 子序列余下部分复制到 tmpa</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmpa[k]=a[i];</span><br><span class="line">        i++;k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)	<span class="comment">//将第 2 子序列余下部分复制到 tmpa</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmpa[k]=a[j];</span><br><span class="line">        j++;k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,i=low;i&lt;=high;k++,i++)	<span class="comment">//将 tmpa 复制回 a 中</span></span><br><span class="line">        a[i]=tmpa[k];</span><br><span class="line">    <span class="built_in">free</span>(tmpa);	<span class="comment">//释放 tmpa 所占内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergePass</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> length,<span class="type">int</span> n)</span> <span class="comment">//一趟二路归并排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i+<span class="number">2</span>*length<span class="number">-1</span>&lt;n;i=i+<span class="number">2</span>*length) <span class="comment">//归并 length 长的两相邻子序列</span></span><br><span class="line">        <span class="built_in">Merge</span>(a,i,i+length<span class="number">-1</span>,i+<span class="number">2</span>*length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(i+length<span class="number">-1</span>&lt;n)	<span class="comment">//余下 2 个子序列，后者长度小于 length</span></span><br><span class="line">        <span class="built_in">Merge</span>(a,i,i+length<span class="number">-1</span>,n<span class="number">-1</span>);	<span class="comment">//归并这 2 个子序列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>	<span class="comment">//二路归并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">for</span>(length=<span class="number">1</span>;length&lt;n;length=<span class="number">2</span>*length)</span><br><span class="line">        <span class="built_in">MergePass</span>(a,length,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>); <span class="built_in">disp</span>(a,n);</span><br><span class="line">    <span class="built_in">MergeSort</span>(a,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>); <span class="built_in">disp</span>(a,n);	<span class="comment">//输出：1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【算法分析】对于上述二路归并排序算法，当有 n 个元素时需要 ⌈log<sub>2</sub>n⌉ 趟归并，每一趟归并，其元素比较词素不超过 n-1，元素移动次数都是 n，因此二路归并排序的时间复杂度为 O(nlog<sub>2</sub>n) 。</p>
<h4 id="2-自顶向下的二路归并排序算法"><a href="#2-自顶向下的二路归并排序算法" class="headerlink" title="2.自顶向下的二路归并排序算法"></a>2.自顶向下的二路归并排序算法</h4><p>上述自底向上的二路归并排序算法虽然效率较高，但可读性较差。另一种是采用自顶向下的方法设计，算法更为简洁，属典型的二分法算法。</p>
<p>实现自顶向下的二路归并排序的完整程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span>	<span class="comment">//输出 a 中的所有元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将 2 个相邻有序子序列归并为一个有序子序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* tmpa;</span><br><span class="line">    <span class="type">int</span> i=low,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    tmpa=(<span class="type">int</span>*)<span class="built_in">malloc</span>((high-low+<span class="number">1</span>)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])	<span class="comment">//将第 1 子序列中的元素放入 tmpa 中</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpa[k]=a[i];</span><br><span class="line">            i++;k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//将第 2 子序列中的元素放入 tmpa 中</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpa[k]=a[j];</span><br><span class="line">            j++;k++;</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)	<span class="comment">//将第 1 子序列余下部分复制到 tmpa</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmpa[k]=a[i];</span><br><span class="line">        i++;k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)	<span class="comment">//将第 2 子序列余下部分复制到 tmpa</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmpa[k]=a[j];</span><br><span class="line">        j++;k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>,i=low;i&lt;=high;k++,i++)	<span class="comment">//将 tmpa 复制回 a 中</span></span><br><span class="line">        a[i]=tmpa[k];</span><br><span class="line">    <span class="built_in">free</span>(tmpa);	<span class="comment">//释放 tmpa 所占内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high)</span>	<span class="comment">//二路归并算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)	<span class="comment">//子序列有两个或以上元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;	<span class="comment">//取序列中间位置</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a,low,mid);	<span class="comment">//对左子序列递归排序</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a,mid+<span class="number">1</span>,high);	<span class="comment">//对右子序列递归排序</span></span><br><span class="line">        <span class="built_in">Merge</span>(a,low,mid,high);	<span class="comment">//将两子序列合并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前：&quot;</span>); <span class="built_in">disp</span>(a,n);</span><br><span class="line">    <span class="built_in">MergeSort</span>(a,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后：&quot;</span>); <span class="built_in">disp</span>(a,n);	<span class="comment">//输出：1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【算法分析】设 MergeSort(a,0,n-1) 算法的执行时间为 T(n)，显然 Merge(a,0,n&#x2F;2,n-1) 合并操作的执行时间为 O(n)，所以得到以下递推式：<br>$$<br>T(n) &#x3D; 1 （当 n&#x3D;1 时）<br>$$</p>
<p>$$<br>T(n) &#x3D; 2T(n&#x2F;2) + O(n)（当 n&gt;1 时）<br>$$</p>
<p>容易推出 T(n)&#x3D;O(nlog<sub>2</sub>n)。</p>
<h2 id="3-3-求解查找问题"><a href="#3-3-求解查找问题" class="headerlink" title="3.3 求解查找问题"></a>3.3 求解查找问题</h2><h3 id="3-3-1-查找最大和次大元素"><a href="#3-3-1-查找最大和次大元素" class="headerlink" title="3.3.1 查找最大和次大元素"></a>3.3.1 查找最大和次大元素</h3><p>【问题描述】对于给定的含有 n 个元素的无序序列，求这个序列中最大和次大的两个不同元素。</p>
<p>【问题求解】对于无序序列 a[low..high]，采用分治法求最大元素 max1 和次大元素 max2 的算法程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> &amp;max1,<span class="type">int</span> &amp;max2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low==high)	<span class="comment">//区间中只有一个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        max1=a[low];</span><br><span class="line">        max2=-INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(low==high<span class="number">-1</span>)	<span class="comment">//区间中只有两个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        max1=<span class="built_in">max</span>(a[low],a[high]);</span><br><span class="line">        max2=<span class="built_in">min</span>(a[low],a[high]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//区间中有两个以上元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> lmax1,lmax2;</span><br><span class="line">        <span class="built_in">solve</span>(a,low,mid,lmax1,lamx2);	<span class="comment">//左区间求 lmax1 和 lmax2</span></span><br><span class="line">        <span class="type">int</span> rmax1,rmax2;</span><br><span class="line">        <span class="built_in">solve</span>(a,mid+<span class="number">1</span>,high,rmax1,rmax2);	<span class="comment">//右区间求 rmax1 和 rmax2</span></span><br><span class="line">        <span class="keyword">if</span>(lmax1&gt;rmax1)</span><br><span class="line">        &#123;</span><br><span class="line">            max1=lmax1;</span><br><span class="line">            max2=<span class="built_in">max</span>(lmax2,rmax1);	<span class="comment">//lmax2、rmax1 中求次大元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            max1=rmax1;</span><br><span class="line">            max2=<span class="built_in">max</span>(lmax1,rmax2);	<span class="comment">//lmax1、rmax2 中求次大元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【算法分析】对于 solve(a,0,n-1,max1,max2) 调用，其比较次数的递推式如下：<br>$$<br>T(1) &#x3D; T(2) &#x3D; 1<br>$$</p>
<p>$$<br>T(n) &#x3D; 2T(n&#x2F;2) + 1 （合并的时间为O(1)）<br>$$</p>
<p>容易推出 T(n)&#x3D;O(n)。</p>
<h3 id="3-3-2-折半查找"><a href="#3-3-2-折半查找" class="headerlink" title="3.3.2 折半查找"></a>3.3.2 折半查找</h3><p>折半查找又称<strong>二分查找</strong>，它是一种效率较高的查找方法。</p>
<p>但是折半查找要求查找序列中的元素是<strong>有序的</strong>，为了简单，假设是递增有序的。</p>
<p>折半查找对应的完整程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> k)</span>	<span class="comment">//折半查找算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;	<span class="comment">//求查找区间的中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(a[mid]==k)	<span class="comment">//找到后返回其物理下标 mid</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;k)	<span class="comment">//当 a[mid]&gt;k 时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch</span>(a,low,mid<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//当 a[mid]&lt;k 时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BinSearch</span>(a,mid+<span class="number">1</span>,high,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//若当前查找区间没有元素时返回 -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">10</span>,i;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    i=<span class="built_in">BinSearch</span>(a,<span class="number">0</span>,n<span class="number">-1</span>,k);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;未找到%d元素\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-寻找一个序列中第-k-小的元素"><a href="#3-3-3-寻找一个序列中第-k-小的元素" class="headerlink" title="3.3.3 寻找一个序列中第 k 小的元素"></a>3.3.3 寻找一个序列中第 k 小的元素</h3><p>【问题描述】</p>
<h3 id="3-3-4-寻找两个等长有序序列的中位数"><a href="#3-3-4-寻找两个等长有序序列的中位数" class="headerlink" title="3.3.4 寻找两个等长有序序列的中位数"></a>3.3.4 寻找两个等长有序序列的中位数</h3><h2 id="3-4-求解组合问题"><a href="#3-4-求解组合问题" class="headerlink" title="3.4 求解组合问题"></a>3.4 求解组合问题</h2><h3 id="3-4-1-求解最大连续子序列和问题"><a href="#3-4-1-求解最大连续子序列和问题" class="headerlink" title="3.4.1 求解最大连续子序列和问题"></a>3.4.1 求解最大连续子序列和问题</h3><h3 id="3-4-2-求解棋盘覆盖问题"><a href="#3-4-2-求解棋盘覆盖问题" class="headerlink" title="3.4.2 求解棋盘覆盖问题"></a>3.4.2 求解棋盘覆盖问题</h3><h3 id="3-4-3-求解循环日程安排问题"><a href="#3-4-3-求解循环日程安排问题" class="headerlink" title="3.4.3 求解循环日程安排问题"></a>3.4.3 求解循环日程安排问题</h3><hr>
<p><a href="https://georgedi.top/posts/a0060000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章 回溯法</title>
    <url>/posts/a0060005.html</url>
    <content><![CDATA[<h2 id="5-1-回溯法概述"><a href="#5-1-回溯法概述" class="headerlink" title="5.1 回溯法概述"></a>5.1 回溯法概述</h2><h3 id="5-1-1-问题的解空间"><a href="#5-1-1-问题的解空间" class="headerlink" title="5.1.1 问题的解空间"></a>5.1.1 问题的解空间</h3><h3 id="5-1-2-什么是回溯法"><a href="#5-1-2-什么是回溯法" class="headerlink" title="5.1.2 什么是回溯法"></a>5.1.2 什么是回溯法</h3><h3 id="5-1-3-回溯法的算法框架及其应用"><a href="#5-1-3-回溯法的算法框架及其应用" class="headerlink" title="5.1.3 回溯法的算法框架及其应用"></a>5.1.3 回溯法的算法框架及其应用</h3><h3 id="5-1-4-回溯法与深度优先遍历的异同"><a href="#5-1-4-回溯法与深度优先遍历的异同" class="headerlink" title="5.1.4 回溯法与深度优先遍历的异同"></a>5.1.4 回溯法与深度优先遍历的异同</h3><h3 id="5-1-5-回溯法的时间分析"><a href="#5-1-5-回溯法的时间分析" class="headerlink" title="5.1.5 回溯法的时间分析"></a>5.1.5 回溯法的时间分析</h3><h2 id="5-2-求解-0-x2F-1-背包问题"><a href="#5-2-求解-0-x2F-1-背包问题" class="headerlink" title="5.2 求解 0&#x2F;1 背包问题"></a>5.2 求解 0&#x2F;1 背包问题</h2><h2 id="5-3-求解装载问题"><a href="#5-3-求解装载问题" class="headerlink" title="5.3 求解装载问题"></a>5.3 求解装载问题</h2><h3 id="5-3-1-求解简单装载问题"><a href="#5-3-1-求解简单装载问题" class="headerlink" title="5.3.1 求解简单装载问题"></a>5.3.1 求解简单装载问题</h3><h3 id="5-3-2-求解复杂装载问题"><a href="#5-3-2-求解复杂装载问题" class="headerlink" title="5.3.2 求解复杂装载问题"></a>5.3.2 求解复杂装载问题</h3><h2 id="5-4-求解子集和问题"><a href="#5-4-求解子集和问题" class="headerlink" title="5.4 求解子集和问题"></a>5.4 求解子集和问题</h2><h3 id="5-4-1-求子集和问题的解"><a href="#5-4-1-求子集和问题的解" class="headerlink" title="5.4.1 求子集和问题的解"></a>5.4.1 求子集和问题的解</h3><h3 id="5-4-2-判断子集和问题是否存在解"><a href="#5-4-2-判断子集和问题是否存在解" class="headerlink" title="5.4.2 判断子集和问题是否存在解"></a>5.4.2 判断子集和问题是否存在解</h3><h2 id="5-5-求解-n-皇后问题"><a href="#5-5-求解-n-皇后问题" class="headerlink" title="5.5 求解 n 皇后问题"></a>5.5 求解 n 皇后问题</h2><h2 id="5-6-求解图的-m-着色问题"><a href="#5-6-求解图的-m-着色问题" class="headerlink" title="5.6 求解图的 m 着色问题"></a>5.6 求解图的 m 着色问题</h2><h2 id="5-7-求解任务分配问题"><a href="#5-7-求解任务分配问题" class="headerlink" title="5.7 求解任务分配问题"></a>5.7 求解任务分配问题</h2><h2 id="5-8-求解活动安排问题"><a href="#5-8-求解活动安排问题" class="headerlink" title="5.8 求解活动安排问题"></a>5.8 求解活动安排问题</h2><h2 id="5-9-求解流水作业调度问题"><a href="#5-9-求解流水作业调度问题" class="headerlink" title="5.9 求解流水作业调度问题"></a>5.9 求解流水作业调度问题</h2><hr>
<p><a href="https://georgedi.top/posts/a0060000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章 贪心法</title>
    <url>/posts/a0060007.html</url>
    <content><![CDATA[<h2 id="7-1-贪心法概述"><a href="#7-1-贪心法概述" class="headerlink" title="7.1 贪心法概述"></a>7.1 贪心法概述</h2><h3 id="7-1-1-什么是贪心法"><a href="#7-1-1-什么是贪心法" class="headerlink" title="7.1.1 什么是贪心法"></a>7.1.1 什么是贪心法</h3><h3 id="7-1-2-用贪心法求解的问题应具有的性质"><a href="#7-1-2-用贪心法求解的问题应具有的性质" class="headerlink" title="7.1.2 用贪心法求解的问题应具有的性质"></a>7.1.2 用贪心法求解的问题应具有的性质</h3><h3 id="7-1-3-贪心法的一般求解过程"><a href="#7-1-3-贪心法的一般求解过程" class="headerlink" title="7.1.3 贪心法的一般求解过程"></a>7.1.3 贪心法的一般求解过程</h3><h2 id="7-2-求解活动安排问题"><a href="#7-2-求解活动安排问题" class="headerlink" title="7.2 求解活动安排问题"></a>7.2 求解活动安排问题</h2><h2 id="7-3-求解背包问题"><a href="#7-3-求解背包问题" class="headerlink" title="7.3 求解背包问题"></a>7.3 求解背包问题</h2><h2 id="7-4-求解最优装载问题"><a href="#7-4-求解最优装载问题" class="headerlink" title="7.4 求解最优装载问题"></a>7.4 求解最优装载问题</h2><h2 id="7-5-求解田忌赛马问题"><a href="#7-5-求解田忌赛马问题" class="headerlink" title="7.5 求解田忌赛马问题"></a>7.5 求解田忌赛马问题</h2><h2 id="7-6-求解多机调度问题"><a href="#7-6-求解多机调度问题" class="headerlink" title="7.6 求解多机调度问题"></a>7.6 求解多机调度问题</h2><h2 id="7-7-哈夫曼编码"><a href="#7-7-哈夫曼编码" class="headerlink" title="7.7 哈夫曼编码"></a>7.7 哈夫曼编码</h2><h2 id="7-8-求解流水作业调度问题"><a href="#7-8-求解流水作业调度问题" class="headerlink" title="7.8 求解流水作业调度问题"></a>7.8 求解流水作业调度问题</h2><hr>
<p><a href="https://georgedi.top/posts/a0060000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章 动态规划</title>
    <url>/posts/a0060008.html</url>
    <content><![CDATA[<h2 id="8-1-动态规划概述"><a href="#8-1-动态规划概述" class="headerlink" title="8.1 动态规划概述"></a>8.1 动态规划概述</h2><h3 id="8-1-1-从求解斐波那契数列看动态规划法"><a href="#8-1-1-从求解斐波那契数列看动态规划法" class="headerlink" title="8.1.1 从求解斐波那契数列看动态规划法"></a>8.1.1 从求解斐波那契数列看动态规划法</h3><h3 id="8-1-2-动态规划的原理"><a href="#8-1-2-动态规划的原理" class="headerlink" title="8.1.2 动态规划的原理"></a>8.1.2 动态规划的原理</h3><h3 id="8-1-3-动态规划求解的基本步骤"><a href="#8-1-3-动态规划求解的基本步骤" class="headerlink" title="8.1.3 动态规划求解的基本步骤"></a>8.1.3 动态规划求解的基本步骤</h3><h3 id="8-1-4-动态规划与其他方法的比较"><a href="#8-1-4-动态规划与其他方法的比较" class="headerlink" title="8.1.4 动态规划与其他方法的比较"></a>8.1.4 动态规划与其他方法的比较</h3><h2 id="8-2-求解整数拆分问题"><a href="#8-2-求解整数拆分问题" class="headerlink" title="8.2 求解整数拆分问题"></a>8.2 求解整数拆分问题</h2><h2 id="8-3-求解最大连续子序列和问题"><a href="#8-3-求解最大连续子序列和问题" class="headerlink" title="8.3 求解最大连续子序列和问题"></a>8.3 求解最大连续子序列和问题</h2><h2 id="8-4-求解三角形最小路径问题"><a href="#8-4-求解三角形最小路径问题" class="headerlink" title="8.4 求解三角形最小路径问题"></a>8.4 求解三角形最小路径问题</h2><h2 id="8-5-求解最长公共子序列问题"><a href="#8-5-求解最长公共子序列问题" class="headerlink" title="8.5 求解最长公共子序列问题"></a>8.5 求解最长公共子序列问题</h2><h2 id="8-6-求解最长递增子序列问题"><a href="#8-6-求解最长递增子序列问题" class="headerlink" title="8.6 求解最长递增子序列问题"></a>8.6 求解最长递增子序列问题</h2><h2 id="8-7-求解编辑距离问题"><a href="#8-7-求解编辑距离问题" class="headerlink" title="8.7 求解编辑距离问题"></a>8.7 求解编辑距离问题</h2><h2 id="8-8-求解-0-x2F-1-问题"><a href="#8-8-求解-0-x2F-1-问题" class="headerlink" title="8.8 求解 0&#x2F;1 问题"></a>8.8 求解 0&#x2F;1 问题</h2><h2 id="8-9-求解完全背包问题"><a href="#8-9-求解完全背包问题" class="headerlink" title="8.9 求解完全背包问题"></a>8.9 求解完全背包问题</h2><h2 id="8-10-求解资源分配问题"><a href="#8-10-求解资源分配问题" class="headerlink" title="8.10 求解资源分配问题"></a>8.10 求解资源分配问题</h2><h2 id="8-11-求解会议安排问题"><a href="#8-11-求解会议安排问题" class="headerlink" title="8.11 求解会议安排问题"></a>8.11 求解会议安排问题</h2><h2 id="8-12-滚动数组"><a href="#8-12-滚动数组" class="headerlink" title="8.12 滚动数组"></a>8.12 滚动数组</h2><h3 id="8-12-1-什么是滚动数组"><a href="#8-12-1-什么是滚动数组" class="headerlink" title="8.12.1 什么是滚动数组"></a>8.12.1 什么是滚动数组</h3><h3 id="8-12-2-用滚动数组求解-0-x2F-1-背包问题"><a href="#8-12-2-用滚动数组求解-0-x2F-1-背包问题" class="headerlink" title="8.12.2 用滚动数组求解 0&#x2F;1 背包问题"></a>8.12.2 用滚动数组求解 0&#x2F;1 背包问题</h3><hr>
<p><a href="https://georgedi.top/posts/a0060000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《软件工程经济学》</title>
    <url>/posts/a0090000.html</url>
    <content><![CDATA[<h2 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h2><h3 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a><a href="https://georgedi.top/posts/a0090001.html">第1章 绪论</a></h3><h3 id="第2章-软件工程经济学基础"><a href="#第2章-软件工程经济学基础" class="headerlink" title="第2章 软件工程经济学基础"></a><a href="https://georgedi.top/posts/a0090002.html">第2章 软件工程经济学基础</a></h3><h3 id="第3章-软件的成本管理与定价分析"><a href="#第3章-软件的成本管理与定价分析" class="headerlink" title="第3章 软件的成本管理与定价分析"></a><a href="https://georgedi.top/posts/a0090003.html">第3章 软件的成本管理与定价分析</a></h3><h3 id="第4章-软件工程项目评价方法与经济效果评价"><a href="#第4章-软件工程项目评价方法与经济效果评价" class="headerlink" title="第4章 软件工程项目评价方法与经济效果评价"></a><a href="https://georgedi.top/posts/a0090004.html">第4章 软件工程项目评价方法与经济效果评价</a></h3><h3 id="第5章-软件生产函数、效益分析及不确定性分析"><a href="#第5章-软件生产函数、效益分析及不确定性分析" class="headerlink" title="第5章 软件生产函数、效益分析及不确定性分析"></a><a href="https://georgedi.top/posts/a0090005.html">第5章 软件生产函数、效益分析及不确定性分析</a></h3><h3 id="第6章-软件工程项目进度计划的制订"><a href="#第6章-软件工程项目进度计划的制订" class="headerlink" title="第6章 软件工程项目进度计划的制订"></a><a href="https://georgedi.top/posts/a0090006.html">第6章 软件工程项目进度计划的制订</a></h3><h3 id="第7章-软件工程项目的团队建设、风险管理及质量管理"><a href="#第7章-软件工程项目的团队建设、风险管理及质量管理" class="headerlink" title="第7章 软件工程项目的团队建设、风险管理及质量管理"></a><a href="https://georgedi.top/posts/a0090007.html">第7章 软件工程项目的团队建设、风险管理及质量管理</a></h3><h3 id="第8章-软件测试"><a href="#第8章-软件测试" class="headerlink" title="第8章 软件测试"></a><a href="https://georgedi.top/posts/a0090008.html">第8章 软件测试</a></h3>]]></content>
      <categories>
        <category>科班基础</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 绪论</title>
    <url>/posts/a0090001.html</url>
    <content><![CDATA[<h2 id="1-1-软件、软件产业与软件企业"><a href="#1-1-软件、软件产业与软件企业" class="headerlink" title="1.1 软件、软件产业与软件企业"></a>1.1 软件、软件产业与软件企业</h2><p>本书所涉及的软件沿用传统的定义，指包括<strong>程序</strong>、<strong>数据</strong>及其<strong>相关文档</strong>的完整集合。</p>
<h3 id="1-1-1-软件的分类及其特点"><a href="#1-1-1-软件的分类及其特点" class="headerlink" title="1.1.1 软件的分类及其特点"></a>1.1.1 软件的分类及其特点</h3><ol>
<li><p><strong>软件的分类</strong></p>
<p>学术界和产业界对软件并没有严格的分类标准，通常可以按照<strong>软件的功能</strong>、<strong>软件的工作方式</strong>、<strong>软件的权益</strong>、<strong>软件的标准化程度</strong>、<strong>软件与硬件的关联程度</strong>、<strong>软件所处的层次</strong>等不同角度进行分类。</p>
<p>下面是几种常用的软件分类方法。</p>
<ul>
<li><p>按<strong>软件的功能</strong>进行分类</p>
<ol>
<li><p><strong>系统软件</strong></p>
<p>系统软件指能与计算机硬件紧密地配合在一起，使计算机系统各个部件、相关的程序和数据协调、高效工作的软件，如操作系统、数据库管理软件、设备驱动程序、通信处理程序等。</p>
</li>
<li><p><strong>支撑软件</strong></p>
<p>支撑软件是指协助用户开发软件的工具性软件和中间件，既包括程序人员开发软件产品的工具，也包括帮助管理人员控制开发进程的工具，如文字处理软件、数据模型构造器、商业图形软件、 C &#x2F; S 开发工具等。</p>
</li>
<li><p><strong>应用软件</strong></p>
<p>应用软件是指在特定领域内开发，为特定目的服务的一类软件。</p>
<p>相较于系统软件和支撑软件，应用软件的涉及面最宽，如呼叫中心控制软件、铁路调度软件、通信控制软件、办公软件、图像处理软件等。</p>
</li>
</ol>
</li>
<li><p>按<strong>软件的工作方式</strong>进行分类</p>
<ol>
<li><p><strong>实时处理软件</strong></p>
<p>实时处理软件是指在当前时间，对当前任务进行处理的软件，如智慧卫生监督软件、实验室信息管理软件等。</p>
</li>
<li><p><strong>多用户分时软件</strong></p>
<p>多用户分时软件指按照一定的时间间隔，阶段性地处理任务的软件，如交通信号灯管理软件等。</p>
</li>
<li><p><strong>交互式软件</strong></p>
<p>交互式软件是指可以互动交流的软件，如电子白板软件、各种移动应用软件等。交互指实现操作者和程序的对话。例如操作者点击某软件的“退出”按钮，软件界面会弹出一个窗口“您真的要退出吗？”，然后操作者可自行选择。</p>
</li>
<li><p><strong>批处理软件</strong></p>
<p>批处理软件指一次可以执行多条指令的软件，如垃圾处理软件等。</p>
</li>
</ol>
</li>
<li><p>按<strong>软件的权益</strong>进行分类</p>
<ol>
<li><p><strong>商品软件</strong></p>
<p>商品软件是指用户需要付费（一般需要购买其软件许可证）才能获得其使用权的软件。</p>
</li>
<li><p><strong>共享软件</strong></p>
<p>共享软件是指一种具有版权的“买前免费试用”软件，通常允许用户试用一段时间，允许用户进行拷贝或散发给其他人，但不允许销售，过了试用期后需要交一笔注册费，成为注册用户方可继续使用。</p>
</li>
<li><p><strong>自由软件</strong></p>
<p>自由软件的创始人是理查德·斯托曼（ Richard Stallman )，他在 1984 年启动了开发类 UNIX 系统的自由软件工程，创建了自由软件基金会，拟订了通用公共版权许可证，倡导自由软件的非版权原则（该原则是：用户可以共享自由软件，允许随意拷贝、修改其源代码，允许销售和自由传播，但对软件源代码的任何修改都必须向所有用户公开，还必须允许此后的用户享有进一步拷贝和修改的权利）。</p>
<p>自由软件有利于软件共享和技术创新，它的出现成就了 TCP &#x2F; IP 协议、 Apache 服务器软件和 Linux 操作系统等一大批精品软件的产生。</p>
</li>
</ol>
</li>
<li><p>按<strong>软件的标准化程度</strong>进行分类</p>
<ol>
<li><p><strong>标准化软件</strong></p>
<p>标准化软件指可以封装发售、购买后就可以直接使用的软件。此类软件标准化程度高，销量大，售价也相对较低，如 Office 办公软件、 Windows 各版本的操作系统等。</p>
</li>
<li><p><strong>半定制软件</strong></p>
<p>半定制软件指具有相当一部分共性，但仍需要一定的客户化开发工作才能满足客户需要的软件，如 ERP ( Enterprise Resource Planning ，企业资源计划）软件、财务软件等。</p>
</li>
<li><p><strong>定制软件</strong></p>
<p>定制软件（又称软件服务）指需要根据特定客户的需求来量身定制的软件，如各种系统集成服务、外包软件等。</p>
</li>
</ol>
</li>
<li><p>按<strong>软件与硬件的关联程度</strong>进行分类</p>
<ol>
<li><p><strong>嵌入型软件</strong></p>
<p>嵌入型软件要求在紧密联系的硬件、软件和操作的限制条件下运行，通常与某些硬件设备结合在一起。因此，嵌入型软件对接口、数据结构、算法要求较高。</p>
<p>嵌人型软件规模可大可小，大如复杂的事务处理系统、大型／超大型的操作系统、航天测控系统、大型指挥系统等，小如手机软件、MP3 播放软件等。</p>
</li>
<li><p><strong>组织型软件</strong></p>
<p>组织型软件（又称有机型软件）指规模相对较小，结构简单的软件。此类软件需求不是很苛刻，开发人员对此类软件产品开发目标的理解充分，工作经验丰富，对软件的使用环境很熟悉，软件受硬件的约束较少，程序的规模不是很大（&lt;5 万行），如住房摇号软件、 OA ( OfficeAutomation ，办公自动化）系统等。</p>
</li>
<li><p><strong>半独立型软件</strong></p>
<p>半独立型软件指介于嵌人型软件和组织型软件之间的软件，其规模和复杂度都属于中等以上，最大可达 30 万行，如财务应用软件等。</p>
</li>
</ol>
</li>
<li><p>按<strong>软件所处的层次</strong>进行分类</p>
<ol>
<li><p><strong>平台软件</strong></p>
<p>平台软件指直接控制和协调计算机、通信设备及其他外部设备，使之发生作用并方便用户使用以及提供中间支持和运行环境的软件。这些软件结合起来可以提供应用软件运行的平台，如操作系统、基于其上的数据库管理系统及开发工具、网络管理软件、中文处理平台软件、图形图像管理软件、人机接口交互软件等。</p>
</li>
<li><p><strong>中间软件</strong></p>
<p>中间软件处于操作系统软件与用户应用软件中间，是为处于自己上层的应用软件提供运行与开发的环境，帮助用户灵活、高效地开发和集成的复杂应用软件。</p>
<p>中间软件主要包括中间件软件和计算机安全软件产品，如交易中间件、消息中间件、应用服务器（ J2EE )、系统集成中间件、企业服务中间件、安全中间件、门户中间件、计算机语言集成中间件、数字电视中间件等。</p>
</li>
<li><p><strong>应用软件</strong></p>
<p>应用软件指直接完成某种具体应用，无需用户重新编程的软件，其应用范围最广、产品最多。应用软件又分为通用应用软件和行业应用软件两类。</p>
<p>通用应用软件包括办公及文字处理软件、通用财会软件、教育软件、游戏与娱乐软件等，行业应用软件涉及金融、电信、政府、教育、能源等。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>软件的特点</strong><br>软件作为一个产品或服务，与硬件产品相比，具有如下特点：</p>
<ol>
<li><strong>软件是信息产品，具有无形性、抽象性、可复制性和共享性。</strong></li>
<li><strong>软件的生产过程几乎都是从零开始。</strong></li>
<li><strong>软件的价值以及成本构成与传统的工业制品不同，如没有库存成本。</strong></li>
<li><strong>软件开发和运行常常受不同的计算机软件和硬件平台的限制，对计算机软件和硬件系统有不同程度的依赖性。</strong></li>
<li><strong>软件的开发过程很复杂。</strong></li>
<li><strong>软件开发是一项创造性活动。</strong></li>
<li><strong>软件开发需要大量的资金投入。</strong></li>
<li><strong>软件产品对用户有黏性。</strong></li>
<li><strong>软件产品的更新速度快。</strong></li>
</ol>
</li>
</ol>
<h3 id="1-1-2-软件产业"><a href="#1-1-2-软件产业" class="headerlink" title="1.1.2 软件产业"></a>1.1.2 软件产业</h3><p>目前，国家有关部门并未对软件产业给出明确的定义。</p>
<p>1996 年的《计算机软件产业技术创新战略研究》报告中对软件产业的定义是：</p>
<p>​	<strong>为有效地利用计算机资源而从事计算机程序编制、信息系统开发和集成及从事相关服务的产业。</strong></p>
<ol>
<li><p><strong>软件产业的分类</strong></p>
<ul>
<li><p>麦肯锡公司（ McKinsey &amp;. Company ）出版发行的《软件业的成功奥秘》中，将软件产业分为<strong>专业化服务</strong>和<strong>软件产品</strong>两类，其中软件产品又分为<strong>企业解决方案</strong>和<strong>大众市场成套软件</strong>。</p>
</li>
<li><p>国际数据公司（ International Data Corporation , IDC ）在做市场研究时，将软件产业细分为如下三大领域：</p>
<ol>
<li><p><strong>应用解决方案（ Solutions )</strong></p>
</li>
<li><p><strong>应用开发与配置软件（ Application Development and Deployment Software ）</strong></p>
</li>
<li><p><strong>系统基础软件（ System Infrastructure Software ）</strong></p>
</li>
</ol>
<p>其中，应用解决方案包括消费应用（如家庭、游戏和娱乐）、协作应用（如集成协作环境、消息应用）、内容管理应用（如内容及文件管理应用）、写作应用（如文字加工）等子项；</p>
<p>应用开发与配置软件包括信息数据管理、应用设计和建筑工具、应用软件生命周期管理等子项；</p>
<p>系统基础软件包括系统管理软件、网络管理软件、安全软件、中间件和系统级软件等子项。</p>
</li>
<li><p>印度将 IT 软件服务产业分为<strong>产品和技术开发业</strong>、<strong>IT 服务业</strong>和 <strong>IT 关联服务业</strong>。</p>
<p>印度将软件服务产业统一扩大为“<strong>IT 服务</strong>”的概念。</p>
</li>
</ul>
</li>
<li><p><strong>软件产业的特点</strong></p>
<ol>
<li><strong>高技术、高附加值及高效益</strong></li>
<li><strong>国际化</strong></li>
<li><strong>服务化</strong></li>
<li><strong>专业化分工越来越细</strong></li>
<li><strong>高关联度</strong></li>
</ol>
</li>
<li><p><strong>软件产业的发展模式</strong></p>
<p>在世界各国的软件产业的发展过程中，形成了多种不同的发展模式，典型的代表有：</p>
<ul>
<li><strong>美国的“全面领先模式”</strong></li>
<li><strong>日本和韩国的“整机带动模式”</strong></li>
<li><strong>爱尔兰的“软件集散模式”</strong></li>
<li><strong>印度的“外包服务模式”</strong></li>
</ul>
</li>
<li><p><strong>我国软件产业的发展特征</strong></p>
<p>相对于软件产业发达国家，我国软件产业发展的历程比较短，萌芽于 20 世纪 70 年代，起步于 20 世纪 80 年代末。随着社会的信息化进程加快，在进入 20 世纪 90 年代后我国软件产业就有了飞速发展。</p>
<p>我国软件产业发展有如下几个特征：</p>
<ul>
<li><p><strong>产值和规模持续扩大</strong></p>
<p>软件产业作为我国基础性、战略性的产业，在促进国民经济和社会发展中具有重要作用。</p>
</li>
<li><p><strong>呈现集聚化发展态势</strong>、</p>
<p>我国软件产业发展聚集趋势从过去主要<strong>集中在京粤地区</strong>转向<strong>沿海地区</strong>。</p>
</li>
<li><p><strong>市场逐步扩大</strong></p>
<p>目前，中国的软件产业仍以国内软件市场需求为主，出口外包为辅，但随着国家对软件产业的支持力度的增加，软件服务外包示范城市对促进产业集聚和培育壮大市场主体的作用越来越重要，中国软件企业正在快速地融入世界经济一体化新的产业分工链条之中。</p>
</li>
</ul>
</li>
<li><p><strong>我国软件产业发展的不足</strong></p>
<p>与国外的软件产业相比，我国的软件产业在发展中存在诸多不足：</p>
<ul>
<li><p><strong>关键核心技术缺乏，自主创新能力薄弱。</strong></p>
<p>我国软件产业由于核心技术缺乏，造成企业产品的附加值低，产品同质化现象非常严重，企业的利润较低。国产基础软件在软件产业的基石作用没有发挥出来，产品主要集中在产业链低端的应用软件，严重缺乏持久的发展动力。我国对软件开发的核心技术不太重视，自主创新能力薄弱，导致在国际软件市场上话语权不足。</p>
</li>
<li><p><strong>软件企业规模小，人才结构不太合理。</strong></p>
<p>我国软件企业 100 人以下的占 70%，且 60％ 的软件企业年营业收入在 50 万元以下。大量的小规模软件公司的存在使得软件市场的竞争非常恶劣，没有大规模的软件龙头企业与国外的大企业抗衡。此外，我国的软件人才结构是两头小、中间大的橄榄形，而不是正常的金字塔形。我国软件产业不仅缺乏软件编码和测试等低端人才，更缺乏包括系统分析师、项目管理人等高端人才。</p>
</li>
<li><p><strong>软件知识产权的保护力度不够。</strong></p>
<p>盗版严重制约了中国软件业的发展，并损害了中国在软件市场上的国际形象。</p>
</li>
</ul>
<p>综上，我们需要正视软件产业所存在的问题，必须抓住当前的机遇和挑战，内外兼修，摒弃自身的不足，积极探索符合中国特色的发展模式。</p>
</li>
</ol>
<h3 id="1-1-3-软件企业"><a href="#1-1-3-软件企业" class="headerlink" title="1.1.3 软件企业"></a>1.1.3 软件企业</h3><p>按照规模的大小，软件企业可分为<strong>大型软件企业</strong>和<strong>中小型软件企业</strong>。</p>
<p>按照所从事的业务范围，软件企业可以分为<strong>软件产品企业</strong>和<strong>软件服务企业</strong>，而软件产品企业又可以分为<strong>开发标准化软件的企业</strong>和<strong>开发半定制软件的企业</strong>。</p>
<ol>
<li><p><strong>软件企业的组织结构</strong></p>
<p>软件企业的组织结构有如下四种：</p>
<ol>
<li><strong>直线职能式组织结构</strong></li>
<li><strong>矩阵式组织结构</strong></li>
<li><strong>事业部制式组织结构</strong></li>
<li><strong>网络式组织结构</strong></li>
</ol>
</li>
<li><p><strong>软件企业的管理</strong></p>
<p>软件企业的管理包括：</p>
<ol>
<li><strong>软件企业的战略管理</strong></li>
<li><strong>软件企业的市场管理</strong></li>
<li><strong>软件企业的项目管理</strong></li>
<li><strong>软件企业的质量管理</strong></li>
<li><strong>软件企业的采购管理</strong></li>
<li><strong>软件企业的人力资源管理</strong></li>
<li><strong>软件企业的知识管理</strong></li>
<li><strong>软件企业的成本管理</strong></li>
<li><strong>软件企业的风险管理</strong></li>
<li><strong>软件企业的文化管理</strong></li>
</ol>
</li>
<li><p><strong>项目管理知识体系</strong></p>
<p>项目管理知识体系的十大知识领域：</p>
<ol>
<li><strong>项目整合管理</strong></li>
<li><strong>项目范围管理</strong></li>
<li><strong>项目进度管理</strong></li>
<li><strong>项目成本管理</strong></li>
<li><strong>项目质量管理</strong></li>
<li><strong>项目资源管理</strong></li>
<li><strong>项目沟通管理</strong></li>
<li><strong>项目风险管理</strong></li>
<li><strong>项目采购管理</strong></li>
<li><strong>项目相关方（干系人）管理</strong></li>
</ol>
</li>
</ol>
<h2 id="1-2-软件工程"><a href="#1-2-软件工程" class="headerlink" title="1.2 软件工程"></a>1.2 软件工程</h2><p>软件自计算机产生以来，虽然飞速发展，但是在早期发展过程中缺乏相关文档且没有较好的开发方法给予指导，导致 20 世纪 60 年代中期出现了“软件危机”。在 20 世纪 60 年代末的 NATO （北大西洋公约组织）会议上，首次提出了“软件工程”一词，即<strong>计划用工程化的方法来实施软件的开发</strong>。</p>
<h3 id="1-2-1-软件工程的定义及其过程"><a href="#1-2-1-软件工程的定义及其过程" class="headerlink" title="1.2.1 软件工程的定义及其过程"></a>1.2.1 软件工程的定义及其过程</h3><p>20世纪90年代，美国电气与电子工程师学会（ Institute of Electrical and Electronics Engineers , IEEE ）给出<strong>软件工程的定义</strong>是：</p>
<ol>
<li><strong>将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护。</strong></li>
<li><strong>对 1 中所述方法的研究。</strong></li>
</ol>
<p>软件工程可以说是一种<strong>层次化</strong>的技术，其根基就在于<strong>对质量的关注及其保障</strong>。</p>
<h3 id="1-2-2-软件工程模型"><a href="#1-2-2-软件工程模型" class="headerlink" title="1.2.2 软件工程模型"></a>1.2.2 软件工程模型</h3><p>软件工程模型又称为<strong>软件开发模型</strong>，是软件从最初的构思到软件公开发行的<strong>全部过程</strong>、<strong>活动</strong>和<strong>任务</strong>的结构框架。</p>
<p>典型的软件工程模型有<strong>瀑布模型</strong>、<strong>V 模型</strong>、<strong>增量模型</strong>、<strong>原型模型</strong>、<strong>螺旋模型</strong>、<strong>喷泉模型</strong>、<strong>基于构件的开发模型</strong>、<strong>形式化方法模型</strong>等。</p>
<h3 id="1-2-3-软件规模度量"><a href="#1-2-3-软件规模度量" class="headerlink" title="1.2.3 软件规模度量"></a>1.2.3 软件规模度量</h3><p>在软件工程项目开始前，要估算该项目所需的开发时间和工作量，即度量软件的规模。</p>
<p>软件规模的度量最主要的技术是<strong>代码行度量</strong>和<strong>功能点度量</strong>。</p>
<ol>
<li><p><strong>代码行度量</strong></p>
<p>软件规模常用程序的<strong>代码行（ Line Of Code , LOC ）</strong>或者<strong>千行代码 kLOC ( 1000LOC ）</strong>来衡量。</p>
<p>代码行度量是一种较为简单的定量估算软件规模的方法，该方法依据以往开发类似产品的经验以及历史数据来估计实现一个功能所需要的源程序行数（不包括注释）。当开发过类似项目且有相关历史数据可以参考时，该估算方法才会相对准确。</p>
<p>为了使程序规模的估算更加接近实际值，可以由多名比较有经验的软件工程师来做出估算。每个人都估计程序的最小规模 a，最大规模 b 以及最可能的规模 m，然后分别算出这三种规模的平均值 <span style="text-decoration: overline">a</span>、<span style="text-decoration: overline">b</span> 和 <span style="text-decoration: overline">m</span>，之后再用下列公式计算程序规模的估算值 L：</p>
<p>$$<br>L &#x3D; \frac{\bar{a} + 4 \bar{m} + \bar{b}}{6}<br>$$</p>
</li>
<li><p><strong>功能点度量</strong></p>
<p>功能点度量主要基于<strong>信息域的特征</strong>以及<strong>软件的复杂性</strong>进行计算。</p>
<p>功能点的计算步骤如下。</p>
<ol>
<li><p><strong>计算信息域特征值加权（ CT ）</strong></p>
<p>表 1 给出了用于功能点度量的五个基本信息域（用户输入数、用户输出数、用户查询数、文件数以及外部接口数）的特征和含义，这些值都是通过直接测量所得。</p>
<p>首先将这些值填入表 2 所示的特征值一栏；其次根据信息域的特征复杂程度来选择表中适当的加权因子；最后对其进行计算，得到总计 CT 值。</p>
<p><strong>表 1 信息域特征及其含义</strong></p>
<table>
<thead>
<tr>
<th align="center">信息域特征名</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">用户输入数</td>
<td align="center">对每个用户输入数进行计数，向软件提供不同的面向应用的数据（不含查询数）</td>
</tr>
<tr>
<td align="center">用户输出数</td>
<td align="center">对每个用户输出数进行计数，向用户提供面向应用的信息（输出是指报表、屏幕、出错消息等，一个报表中的单个数据项不做单独计数）</td>
</tr>
<tr>
<td align="center">用户查询数</td>
<td align="center">一个查询被定义为一次联机输入，它导致软件以联机输出的方式产生实时地响应，且每个不同的查询必须分别计算</td>
</tr>
<tr>
<td align="center">文件数</td>
<td align="center">对每个逻辑上的主文件进行计数（即数据的一个逻辑组合，可能是一个独立的文件或者某个大型数据库的一部分）</td>
</tr>
<tr>
<td align="center">外部接口数</td>
<td align="center">对所有机器可读的接口（如存储介质上的数据文件）进行计数</td>
</tr>
</tbody></table>
<p><strong>表 2 信息域特征计数表</strong></p>
<table>
    <thead>
        <tr align="center">
            <th rowspan="2">基本信息域</th>
            <th rowspan="2">特征值</th>
            <th colspan="3">加权因子 a<sub>i</sub></th>
            <th rowspan="2">结果（特征值*加权因子）</th>
        </tr>
        <tr align="center">
            <td>简单</td>
            <td>中间</td>
            <td>复杂</td>
        </tr>
    </thead>
    <tbody>
        <tr align="center">
            <td>用户输入数</td>
            <td></td>
            <td>3</td>
            <td>4</td>
            <td>6</td>
            <td></td>
        </tr>
        <tr align="center">
            <td>用户输出数</td>
            <td></td>
            <td>4</td>
            <td>5</td>
            <td>7</td>
            <td></td>
        </tr>
        <tr align="center">
            <td>用户查询数</td>
            <td></td>
            <td>3</td>
            <td>4</td>
            <td>6</td>
            <td></td>
        </tr>
        <tr align="center">
            <td>文件数</td>
            <td></td>
            <td>7</td>
            <td>10</td>
            <td>15</td>
            <td></td>
        </tr>
        <tr align="center">
            <td>外部接口数</td>
            <td></td>
            <td>5</td>
            <td>7</td>
            <td>10</td>
            <td></td>
        </tr>
        <tr align="center">
            <td>总计 CT 数</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>

<p>如果用 d,( 1≤ d ,≤5 ）分别表示 5 个基本信息域的特征值， a,( 1≤ a ,≤5 ）表示其对应的加权因子，则 CT 值的计算如下：</p>
<p>$$<br>CT &#x3D; \sum_{j&#x3D;1}^{5}a_{j}d_{j}<br>$$</p>
</li>
<li><p><strong>计算技术复杂性因子（ Technology Complexity Factor , TCF )</strong></p>
<p>环境复杂性因子 F<sub>i</sub>,( i &#x3D;1,2,…,14 ）是基于表 3 中对 14 个问题的评估所得到的值，对每个问题的取值范围是 0~5，如表 4 所示。</p>
<p><strong>表 3 环境复杂性因子取值表</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>问题</th>
<th align="center">F<sub>i</sub>（0~5）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>系统需要可靠的备份和恢复吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td>系统需要数据通信吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td>系统有分布处理功能吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td>系统的性能非常关键吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td>系统是否在一个现存的、重复的操作环境中运行？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">6</td>
<td>联机数据登录是否需要在多屏幕或多操作之间切换以完成输入？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">7</td>
<td>需要联机数据登录吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">8</td>
<td>系统需要联机更新文件吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td>输入、输出文件或查询很复杂吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">10</td>
<td>内部处理复杂吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">11</td>
<td>代码需要设计成可复用的吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">12</td>
<td>设计中需要包含转换及其安装吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">13</td>
<td>系统的设计支持不同组织的多次安装吗？</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">14</td>
<td>系统相关应用的设计便于用户修改和使用吗？</td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>表 4 复杂度取值表</strong></p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">没有影响</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">偶然的</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">适中的</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">普通的</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">重要的</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">极其重要的</td>
</tr>
</tbody></table>
<p>技术复杂性因子的计算公式如下所示：</p>
<p>$$<br>TCF &#x3D; 0.65 + 0.01 \sum_{i&#x3D;1}^{14}F_{i}<br>$$</p>
</li>
<li><p><strong>计算功能点（ FP ）</strong></p>
<p>功能点的计算公式如下所示：</p>
<p>$$<br>FP &#x3D; CT · TCF<br>$$</p>
</li>
</ol>
</li>
</ol>
<p>【例1.1】某软件企业根据客户需求对预定软件进行功能点度量，5 个基本信息域的特征值 d<sub>j</sub>，按照表 1 所示的顺序分别为：用户输入数 35、用户输出数 58、用户查询数 20、文件数 6、外部接口数 2；其对应的加权因子分别为中间（4）、中间（5）、中间（4）、中间（10）和简单（2）；对照表 3 和表 4 的各项指标得到 F<sub>i</sub> 的加权和为 20，试计算其功能点。</p>
<p>解：</p>
<p>（1）依据题目所给条件及表 2，则有<br>$$<br>CT &#x3D; \sum_{j&#x3D;1}^{5}a_{j}d_{j} &#x3D; 35 × 4 + 58 × 5 + 20 × 4 + 6 × 10 + 2 × 5 &#x3D; 580<br>$$<br>（2）根据技术复杂性因子计算公式，有<br>$$<br>TCF &#x3D; 0.65 + 0.01 \sum_{i&#x3D;1}^{14}F_{i} &#x3D; 0.65 + 0.01 × 20 &#x3D; 0.85<br>$$<br>（3）根据功能点计算公式，有<br>$$<br>FP &#x3D; CT · TCF &#x3D; 580 × 0.85 &#x3D; 493<br>$$<br>（4）答：该预定软件的功能点为 493。</p>
<h3 id="1-2-4-程序复杂性度量"><a href="#1-2-4-程序复杂性度量" class="headerlink" title="1.2.4 程序复杂性度量"></a>1.2.4 程序复杂性度量</h3><p>软件的复杂性是指<strong>理解及处理软件的难易程度</strong>，既包括<strong>程序的复杂性</strong>，又包括<strong>文档的复杂性</strong>。</p>
<p>软件的复杂性主要体现在程序的复杂性中，故本节主要介绍程序复杂性的度量。</p>
<p>一般而言，开发规模相同、复杂性却不同的程序，所花费的时间和成本会有较大的差异， K . Magel 从以下六个方面来描述程序的复杂性：</p>
<ol>
<li>程序理解的难度。</li>
<li>纠错、维护程序的难度。</li>
<li>向他人解释程序的难度。</li>
<li>按指定方法修改程序的难度。</li>
<li>根据设计文件编写程序的工作量大小。</li>
<li>执行程序时需要资源量的多少。</li>
</ol>
<p>程序的复杂性度量模型一般遵循以下基本原则：</p>
<ol>
<li>程序的复杂性与程序大小的关系不是线性的。</li>
<li>控制结构复杂的程序比较复杂。</li>
<li>数据结构复杂的程序比较复杂。</li>
<li>转向语句使用不恰当的程序比较复杂。</li>
<li>循环结构比选择结构复杂，选择结构比顺序结构复杂。</li>
<li>语句、数据、子程序以及模块在程序中的次序对复杂性有影响。</li>
<li>全局变量、非局部变量较多时的程序比较复杂。</li>
<li>参数按地址调用比按值调用复杂。</li>
<li>函数的隐式副作用比显式参数传递更难以理解。</li>
<li>具有不同作用的变量共用一个名字时比较难理解。</li>
<li>模块间、子程序间联系密切的程序较为复杂。</li>
<li>嵌套深度越深的程序越复杂。</li>
</ol>
<p>比较典型的程序复杂性度量有 <strong>McCabe 环形复杂性度量</strong>以及 <strong>Halstead 复杂性度量</strong>。</p>
<ol>
<li><p><strong>McCabe 环形复杂性度量</strong></p>
<ol>
<li><p>20 世纪 70 年代， McCabe 提出了基于软件程序图的程序复杂性度量方法。</p>
<p>该方法主要用一种退化的程序流程图来表示程序图。</p>
<p>程序流程图中的每一个处理符号（如起点、终点、处理框以及判断框）用一个结点来表示，而原流程图中连接处理符号的控制流则用程序图中连接结点的有向弧来表示。</p>
<p>McCabe 环形复杂性度量方法是基于图论，对于一个强连通的有向图 G ，若用 e 表示弧数， n 表示结点数， p 表示强连通分量的个数，则可用下列公式表示：</p>
<p>$$<br>V(G) &#x3D; e - n + p<br>$$</p>
<p>对于一个单入口且单出口的程序来说，从入口的结点能到达图中的任意结点，同理从任一结点都可以到达出口结点，故程序图都是连通的，其连通分量只有一个，即 p &#x3D; 1。</p>
<p>但程序图经常不是强连通的，只有在程序图中增加一条从出口结点到入口结点的弧才能将程序图变成强连通的。</p>
<p>为了简化环形的复杂性计算，通常用下列公式进行计算：</p>
<p>$$<br>V(G) &#x3D; e - n + 2<br>$$</p>
</li>
</ol>
</li>
<li><p><strong>Halstead 复杂性度量</strong></p>
<p>Halstead 提出通过定量的公式计算方法来度量软件的复杂性。</p>
<p>Halstead 指出程序是由操作符与操作数组成的符号序列，操作符主要包括算术操作符、逻辑操作符、分界符、赋值符、括号及子程序调用符等，还包括一些单个操作符，如“begin … end”“for … do”“while … do”“repeat … until”以及“if then … else”等。</p>
<p>操作数则是由程序定义且引用的操作对象，可以是常量、变量、记录、指针、数组等。</p>
<p>用 n<sub>1</sub> 表示程序中不同操作符的个数，n<sub>2</sub> 表示程序中不同操作数的个数， N<sub>1</sub>  表示程序中操作符的总数，N<sub>2</sub>  表示程序中操作数的总数。</p>
<p>则可用下列公式 1 表示<strong>程序的符号长度</strong>：</p>
<p>$$<br>N &#x3D; N_{1} + N_{2}<br>$$</p>
<p>用下列公式 2 表示<strong>程序的词汇量</strong>：</p>
<p>$$<br>n &#x3D; n_{1} + n_{2}<br>$$</p>
<p>用下列公式 3 表示<strong>程序量（即存储容量）</strong>，即长度方程：</p>
<p>$$<br>V &#x3D; Nlog_{2}(n_{1} + n_{2}) &#x3D; (N_{1} + N_{2})log_{2}(n_{1} + n_{2})<br>$$</p>
<p>一般认为最小的程序只有两个操作符，即函数调用与赋值，即 n<sub>1</sub> &#x3D; N<sub>1</sub> &#x3D; 2，操作数 n<sub>2</sub> 则是指赋予函数值的变量以及函数调用时的参数，即 n<sub>2</sub><sup>*</sup> &#x3D; n<sub>2</sub> &#x3D; N<sub>2</sub>。</p>
<p>代入公式 3 可得下列<strong>最小程序量计算公式</strong>：<br>$$<br>V^* &#x3D; {(2 + n_2^*)}log_2{(2 + n_2^*)}<br>$$</p>
<p><strong>预测程序长度</strong>如下列公式所示：<br>$$<br>N^{‘} &#x3D; 2 + n_{2}^{*}<br>$$</p>
<p><strong>预测程序潜在的错误数</strong>如下列公式所示：<br>$$<br>B^{‘} &#x3D; \frac{V}{3000}<br>$$</p>
</li>
</ol>
<h3 id="1-2-5-软件可靠性度量"><a href="#1-2-5-软件可靠性度量" class="headerlink" title="1.2.5 软件可靠性度量"></a>1.2.5 软件可靠性度量</h3><p>软件的可靠性是指在规定的时间内以及规定的条件下，软件按照规格说明要求不会引起系统失效的概率。软件的可靠性是关系到系统成败的重要因素。一般情况下，软件的可靠性和软件的故障率是紧密相关的。当软件出现故障时，就需要对其进行修复，而软件修复时间的长短也是直接影响软件可靠性的重要因素。</p>
<p>软件可靠性通常用下列公式进行计算：</p>
<p>$$<br>MTBF &#x3D; MTTF + MTTR<br>$$</p>
<p>其中，MTBF（ Mean Time Between Failure ）是指平均故障间隔时间，MTTF（ Mean Time To Failure ）是指平均故障时间，而 MTTR（ Mean Time To Repair ）则是指平均修复时间。</p>
<p>软件的可用性是指软件在投入使用时能实现其事先指定的相关系统功能的概率，可用下列公式乘以 100% 进行计算：</p>
<p>$$<br>\frac{MTTF}{MTTF + MTTR}<br>$$</p>
<h2 id="1-3-软件工程经济学简介"><a href="#1-3-软件工程经济学简介" class="headerlink" title="1.3 软件工程经济学简介"></a>1.3 软件工程经济学简介</h2><p><strong>经济学是研究人类在生产、消费、分配、交换等经济活动过程中的资源配置与资源利用的学科，属于社会科学。经济学的研究对象是由稀缺性引起的各种选择的问题。</strong></p>
<ol>
<li><p><strong>软件工程经济学的内涵与任务</strong></p>
<p>软件工程经济学（ Software Engineering Economics , SEE ）是<strong>属于软件工程学和工程经济学之间的交叉学科</strong>。</p>
<p>我们将其定义为<strong>以研究软件工程领域中的经济问题和经济规律为主的一门经济学分支学科，是为实现特定功能需求的软件工程项目而提出的一门系统方法学科。</strong></p>
<p>软件工程经济学主要包括以下四部分的内容：</p>
<ol>
<li>学科研究的对象、任务、特征、研究范围与研究方法；</li>
<li>软件系统的内部构成要素与经济活动及其关联分析，如投资、融资、工期、成本、效益、效率、质量保证、开发、管理、运行与维护等及其关联分析；</li>
<li>软件系统的组织结构、管理决策以及与经营活动的关系；</li>
<li>软件系统的资金流、物流、信息流的输入和输出以及对系统外部（如国家、地区社会、经济等）的影响。</li>
</ol>
<p>其中，1 是软件系统的基础概念与理论部分，2、3 为软件系统的微观经济分析部分，4 为软件系统的宏观经济分析部分。</p>
</li>
<li><p><strong>软件工程经济学的研究特点与方法体系</strong></p>
<ul>
<li><p>软件工程经济学的<strong>研究特点</strong></p>
<p>软件工程经济学的研究特点主要有以下四点：</p>
<ol>
<li>软件工程经济学研究的重点始终围绕着软件产品的质量、成本／效益、项目进度、效率等目标要素的关联分析，以及人的组织与协调管理。</li>
<li>软件工程经济学的研究思想主要来自系统工程，因此软件系统目标的整体性、勇素的层次性与关联性、系统环境的适应性等始终是人们研究的指导准则。</li>
<li>软件工程经济学采用定量与定性分析相结合、理论与实践相结合的方式进行研究。</li>
<li>考虑到我国与西方发达国家在文化与价值观念、技术水平、经营机制、管理水平与生产效率以及软件工程环境上的差异，我们在大力学习与借鉴西方发达国家有关软件工程经济学的理论、方法与应用成果的同时，还要注意环境的差异性对数量分析的影响，可在数学分析的思路与方法的通用性基础上来寻找适合于我国国情的研究结果。</li>
</ol>
</li>
<li><p>软件工程经济学的<strong>方法体系</strong></p>
<p>软件工程经济学作为一门交叉学科，其理论与方法体系与以下五类学科有着紧密的关系：</p>
<ol>
<li>管理学、社会学等；</li>
<li>经济学，主要包括微观经济学、宏观经济学、工程经济学、管理经济学、信息经济学等；</li>
<li>软件工程学，主要包括软件工程技术学、软件工程管理学；</li>
<li>计算机通信网络与信息系统；</li>
<li>系统工程与运筹学、应用统计学、模糊数学、系统动力学等。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>软件工程经济学的研究与发展</strong></p>
<p>软件工程诞生于“软件危机”。软件危机是指在计算机软件开发中的一系列问题，其中既有软件技术问题，也有经济问题，如软件开发过程中成本和进度估算往往不精确，软件目标（成本、工期）不确定等。因此，软件工程经济学的研究始终是伴随着软件工程的发展而发展的，且日渐成熟的运筹学、应用统计学、系统工程学、工程经济学也为其发展提供了科学而系统的方法论。20 世纪 70 年代，软件工程经济学的研究对象均来源于计算机科学与软件工程中的范例，希望通过建造、使用工具原型来降低软件开发与维护成本，此后逐渐发展为对软件成本、时间进度、可靠性、各种方案的比较和选优，对软件开发过程的系统动力学研究以及软件企业管理中的采购、计划、生产、销售、运行与维护等最优决策进行研究。目前，软件工程经济学已经发展到对软件工具的经济评价以及在软件开发与维护过程中提高劳动生产率的研究上。</p>
<p>软件工程经济学的研究最早始于美、英等国家，其中较有影响的有 B . W . Boehm 、 Putnam L . H ．以及 Banard L ．等专家。 B . W . Boehm 在研究成本测算的过程中提出了结构化成本模型（ Constructive Cost Model , COCOMO )，给出了由软件规模计算工作量，进而确定成本与工期的经验统计模型，并于1981年出版了其专著《 Software Engineering Economics 》。在将该模型推向市场的同时， B . W . Boehm 不断收集用户反馈意见与建议，进而对模型进行不断修正与提高，以适应软件工程在生存周期、技术、组件、工具表示法以及企业文化等方面的明显变化，并提出了 COCOMOII 的模型与方法体系，并于 2000 年出版了他的第二本有重大影响力的著作《 Software Cost Estimation with COCOMOII 》。 Putnam L . H ．于1987年在其研究的 Noder - Rayleigh （诺顿﹣瑞利）曲线基础上，提出了软件开发与运行过程的系统动力学模型。1987年，美国卡内基一梅隆大学软件工程研究所在 Mitre 公司的支持以及美国国防部的指导下，经过广泛调查，开发了“软件工程评估”和“软件成熟度评价”两个模型。经过四年的使用与论证， Putnam L . H ．于1991年公布和发表了软件能力成熟度模型 CMM ( Capability Maturity Model for Software )。1999 年，美国国防部规定，承接美国国防部大型软件工程项目的承包商必须具备 CMM3 级认证。</p>
<p>我国软件工程经济学的研究还处于初级发展阶段，1990 年和 1991 年由机械工业出版社相继出版了 B . W . Boehm 的著作《软件工程经济学》和 Londeix B ．的著作《软件开发成本估算》，对软件工程经济学的概念、方法宣传起到了一定的作用。西安电子科技大学的赵玮教授于 2008 年出版的《软件工程经济学》，对我国软件工程经济学的发展起到了指引作用。在国内的一些学术期刊上也常常有一些关于软件成本测算、定价策略、软件质量评估等方面的论文发表。不少软件企业也开始了 CMM 评估与认证工作。但从总体来看，我国软件工程产业对软件工程经济学不是特别熟知，从事软件工程经济学专门研究的人员也较少。近几年，由于大数据学科的飞速发展，很多软件企业开始重视信息数据的收集，为以后软件工程经济学的发展起到了很好的奠基作用。我们相信，在国家科技部门的领导下，在我国学术界与企业界的努力下，在不久的将来，我国软件工程经济学的理论与应用水平必将取得新的突破。</p>
</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章 软件工程经济学基础</title>
    <url>/posts/a0090002.html</url>
    <content><![CDATA[<h2 id="2-1-软件工程经济分析的基本要素"><a href="#2-1-软件工程经济分析的基本要素" class="headerlink" title="2.1 软件工程经济分析的基本要素"></a>2.1 软件工程经济分析的基本要素</h2><p>软件工程经济分析的基本要素有<strong>投资</strong>、<strong>筹资与融资</strong>、<strong>成本与费用</strong>、<strong>销售收入与利润</strong>、<strong>主要税金</strong>等。</p>
<h3 id="2-1-1-投资的基本概念及其构成"><a href="#2-1-1-投资的基本概念及其构成" class="headerlink" title="2.1.1 投资的基本概念及其构成"></a>2.1.1 投资的基本概念及其构成</h3><p>投资是指国家、企业或者个人，为了实特定的目的，与对方签订协议，实现互惠互利、输送资金的过程或者相关经济活动。</p>
<p>投资通常有广义和狭义之分。</p>
<ul>
<li>广义的投资一般指人们为了获取将来的报酬，事先投入一定资源的经济行为</li>
<li>狭义的投资指人们在社会生产活动中为了实现某项预定的生产而预先垫付的资金</li>
</ul>
<p>本章涉及的投资主要指<strong>狭义的投资</strong>。</p>
<p>企业的投资活动主要分为<strong>生产性投资</strong>和<strong>非生产性投资</strong>。</p>
<ul>
<li>生产性投资主要是企业为了实现对内扩大再生产建设而进行的投资，如购置固定资产、无形资产和其他长期资产。</li>
<li>非生产性投资主要是企业为了实现对外扩张而投入到非物质生产领域的投资，如对外购买股权、债券、股票等。</li>
</ul>
<p>本章主要研究<strong>生产性投资</strong>。</p>
<p>建设项目投资指企业为完成工程项目的建设，在建设期投入的全部费用的总和，主要包括固定资产、流动资产、无形资产和其他资产等。其铺底流动资金一般为项目正常营运流动资金的 30%。</p>
<p>软件工程项目的建设属于建设项目投资的范畴。</p>
<ol>
<li><p><strong>固定资产</strong></p>
<p>固定资产是指企业为了生产产品、提供劳务、出租或经营管理而持有的使用周期超过一年，且价值达到一定标准的非货币资产。</p>
<p>固定资产投资主要用于扩大再生产和技术设备更新。</p>
<p>固定资产在使用的过程中能保持原有的实物形态，但其价值随着使用会造成损耗，其损耗一般按照折旧的方式计入产品成本。</p>
<p>固定资产的折旧是指固定资产在一定时期内为弥补其损耗而按照规定的固定资产折旧率提取的固定资产折旧费用。</p>
<p>固定资产的损耗分为有形损耗和无形损耗。</p>
<p>有形损耗又称为物理损耗，指的是固定资产由于使用及自然力的影响而引起的价值损失；而无形损耗则指的是机器设备由于技术进步而引起的价值损耗。</p>
<p>固定资产的折旧费需要按其使用过程中的每个会计期间进行提取，作为折旧基金累计，由每个会计期间的产品销售收入逐步补偿。</p>
<p>固定资产的原值减去累计的折旧费为固定资产的净值。</p>
<p>软件企业的固定资产主要有厂房及其附属物、电子设备（如计算机及其外围设备、打印机、复印机、各种开发工具等）、运输工具及其他固定资产。</p>
</li>
<li><p><strong>流动资产</strong></p>
<p>流动资产指企业可在一年或者超过一年的一个营业周期内变现或使用的资产。</p>
<p>流动资产投资主要用于保证企业正常的生产经营，是一次性计人产品成本，并由当期的产品销售收入来补偿的。</p>
<p>流动资产主要包括货币资金、各种存款、应收账款、预付账款、短期投资以及存货等。</p>
</li>
<li><p><strong>无形资产</strong></p>
<p>无形资产是指企业拥有或者控制的没有实物形态但可辨认的非货币性资产。</p>
<p>无形资产主要包括商标权、专利权、软件著作权、商誉、长期股权投资以及土地使用权等。</p>
<p>无形资产自其使用之日开始，在其有效使用期内以平均摊销的方式计入每个会计期间的“管理费用”。</p>
</li>
<li><p><strong>其他资产</strong></p>
<p>其他资产是指不能被包括在固定资产、流动资产和无形资产等项目之内的资产。</p>
<p>在软件工程项目或者系统集成项目筹建期内实际发生的各项费用，除应计入固定资产与无形资产的，都应计入其他资产。</p>
<p>其他资产投资指企业形成其他资产而发生的各项费用支出，如租入固定资产的改良支出等。</p>
</li>
</ol>
<h3 id="2-1-2-筹资与融资"><a href="#2-1-2-筹资与融资" class="headerlink" title="2.1.2 筹资与融资"></a>2.1.2 筹资与融资</h3><p>资金是任何一个投资方案存续的基础。资金的筹集是软件工程项目建设和运行的基本保证。软件工程项目的资金来源，按照所取得资金的权益特性不同可分为权益资金和负债资金。以权益方式筹集的资金，资金的提供方将取得企业的产权；而以负债方式筹集的资金，资金的提供方只取得对于企业的债权，一般债权人优先于股权受偿，但对企业没有控制权。</p>
<ol>
<li><p><strong>筹资</strong></p>
<ol>
<li><p>权益资金</p>
<p>权益资金主要分为<strong>企业融资项目资本金</strong>和<strong>项目融资项目资本金</strong>。</p>
<ol>
<li><strong>软件企业现有资金</strong></li>
<li><strong>软件企业未来生产经营中获得的可用于软件工程项目建设的资金</strong></li>
<li><strong>软件企业资产变现资金</strong></li>
<li><strong>软件企业增资扩股资金</strong></li>
</ol>
</li>
<li><p>负债资金<br>负债资金是指软件工程项目筹资过程中除去资本金外，以负债的方式所筹集的资金。</p>
<ol>
<li><strong>银行贷款</strong></li>
<li><strong>出口信贷</strong></li>
<li><strong>外国政府贷款</strong></li>
<li><strong>国际金融机构贷款</strong></li>
<li><strong>发行债券</strong></li>
<li><strong>融资租赁</strong></li>
</ol>
</li>
</ol>
</li>
<li><p><strong>融资</strong></p>
<p>传统融资是指企业运用各种方式向金融机构筹集资金的一种业务活动，包括取得发行股票、银行贷款、发行债券等。</p>
<p>相对于传统融资来说，项目融资是一种新型融资方式。</p>
<p>项目融资是以项目公司为融资主体，以项目未来收益和资产为融资基础，由项目参与各方共同承担风险，具有有限追索权性质的特定融资方式。</p>
<p>项目融得的资金是一种仅有有限追索权或无限追索权的贷款，且需要的资金量较大，因而其风险也较大。</p>
<p>项目融资分为<strong>无限追索权融资</strong>和<strong>有限追索权融资</strong>两类。</p>
<p>软件工程项目的融资从投资决策到最后完成融资通常要经过五个阶段：</p>
<p><strong>第 1 阶段 投资决策</strong></p>
<p>① 软件工程项目可行性研究</p>
<p>② 投资决策：初步确定项目投资结构</p>
<p><strong>第 2 阶段 融资决策</strong></p>
<p>① 选择融资结构，确定融资方式</p>
<p>② 明确融资目标及其任务</p>
<p><strong>第 3 阶段 融资结构</strong></p>
<p>① 分析软件工程项目风险因素</p>
<p>② 设计融资结构</p>
<p>③ 修正风险控制方式建立法律框架</p>
<p><strong>第 4 阶段 融资谈判</strong></p>
<p>① 选择银行，发出项目融资建议书</p>
<p>② 组织贷款</p>
<p>③ 起草融资法律文件</p>
<p>④ 融资谈判</p>
<p><strong>第 5 阶段 融资执行</strong></p>
<p>① 签署融资文件</p>
<p>② 执行项目投资计划</p>
<p>③ 贷款银行监督并参与决策</p>
<p>④ 项目风险控制与管理</p>
<ol>
<li><p><strong>资金成本</strong></p>
<p>资金成本是指企业在筹集资金的时候所支付的费用，主要包括资金占用费与筹资费。</p>
<p>资金占用费是指占用资金应付的费用，如使用发行股票所筹集的资金需要向其股东支付红利、股息以及向银行借款支付的利息等。</p>
<p>筹资费是指在企业筹集资金的过程中发生的各项费用，如向银行借款所支付的手续费，委托金融机构发行股票所支付的代理费和注册费，发行债券所支付的律师费、印刷费、公证费及广告宣传费等。</p>
<p>由于不同项目所筹集的资金数额不一样，为了方便比较，资金成本通常以相对数来表示，即资金的成本数，如下列公式所示：<br>$$<br>K &#x3D; \frac{D}{P-F} 或 K &#x3D; \frac{D}{P(1-f)}<br>$$<br>式中， K 指资金成本率； D 指使用费； P 指筹集资金的总额； F 指筹资费； f 指筹资费费率（筹资费和筹资总额的比率）。</p>
<p>资金成本是企业财务管理中一个非常重要的概念，在软件企业生产经营活动中用途广泛。</p>
<ol>
<li>资金成本是选择资金来源、设计筹资方案的主要依据。筹资决策主要通过优选各种筹资方式，在满足企业资金需求的前提下，使其资金成本达到最低。</li>
<li>资金成本是评价软件工程项目投资可行性的主要经济依据。只有资金利润率高于资金成本率的项目才值得筹资。</li>
<li>资金成本可以作为评价软件企业财务经营成果的依据之一。</li>
</ol>
</li>
<li><p><strong>自有资金成本计算</strong></p>
<ol>
<li><p>普通股资金成本。</p>
<p>普通股持有者拥有企业的普通股权，企业的资产以及经营收益扣除负债与优先股之后归普通股股权所有，企业的权益归普通股股东所有。</p>
<p>普通股股东对于企业投资的预期收益要求，可征询投资方的意见得知，当不具备征询条件时，可采用资本定价模型，根据同行业的类似项目收益确定。采用风险系数 β 的资本定价模型，如下列公式所示：<br>$$<br>i &#x3D; i_0 + β (i_m - i_0)<br>$$<br>式中， i 表示普通股资金成本； i<sub>0</sub> 表示社会无风险投资收益率；i<sub>m</sub> 表示社会平均投资收益率；β 表示行业的资本投资风险系数。</p>
<ol start="2">
<li><p>优先股资金成本。</p>
<p>优先股类似于负债融资，资金成本按照优先股股息与发行优先股所取得的资金之比进行计算，如下列公式所示：<br>$$<br>i &#x3D; \frac{优先股股息}{优先股发行价格-发行成本} &#x3D; \frac{优先股面值 × 股息}{优先股发行价格 - 优先股面值 × 发行成本所占比重}<br>$$<br>式中，i 表示优先股资金成本。</p>
</li>
</ol>
</li>
</ol>
<p>【例2.1】某 IT 企业优先股面值50元，发行价格为55元，发行成本占优先股面值的 4%，每年付息一次，固定股息为 6%，试求此优先股的资金成本。</p>
<p>解：</p>
<p>i &#x3D; (50 × 6%) &#x2F; (55 - 50 × 4%) ×100% &#x3D; 3 &#x2F; 53 × 100% &#x3D; 5.66% </p>
<p>答：此优先股的资金成本为 5.66%。</p>
</li>
<li><p><strong>保留利润的资本本金</strong></p>
<p>保留利润又称为利润留存，是指企业从税后利润总额中扣除股利后的剩余部分，所有权是企业投资者。</p>
<p>这些未分配保留利润的最低成本是股票本身的资金成本（ i<sub>s</sub> )，也可采用普通股资金成本的方法进行确定。</p>
</li>
<li><p><strong>综合资金成本</strong></p>
<p>当一个企业的不同资金来源的资金成本计算出来后，如果把某一时期内的全部投资视为一个整体的话，就应在分别计算得到各类资金的资金成本的基础上，用加权平均法计算出综合资金成本值，如下列公式所示：<br>$$<br>i_w &#x3D; \sum{i_kf_k}<br>$$<br>式中， i<sub>w</sub> 表示加权平均资金成本； i<sub>k</sub> 表示第 k 种融资的资金成本； f<sub>k</sub> 表示第 k 种融资所占的资金权重，Σ f<sub>k</sub> &#x3D; 1。</p>
<p>综合资金成本可以作为软件工程项目的最低期望收益率，也可称为基准收益率，作为软件工程项目财务内部收益率的判别标准。当软件工程项目财务内部收益率高于综合资金收益成本时，就表示该项目的投资收益水平可以满足项目筹资的资金成本要求，否则表示不满足筹资的资金成本要求。</p>
<p>【例2.2】某 IT 企业的某信息化项目总融资金额为 6000 万元人民币，其中银行贷款 3000 万元，利率为 8%，每年计息两次；发行优先股 2000 万元，股息 9%，发行成本为 3%,平价发行，每年付息一次；发行普通股 1000 万元，据调查其长期国债利率（社会无风险投资收益）为 6%，社会平均收益 14%，投资风险系数为 1.3。请计算该信息化项目的基准收益率（企业所得税按 25％ 计算）。</p>
<p>解：</p>
<p>① 先计算各种资金的税前资金成本：</p>
<p>银行借款资金成本 ＝ [ ( 1 + 8% &#x2F; 2 )<sup>2</sup> - 1 ] × 100% &#x3D; 8.16%</p>
<p>优先股资金的资金成本 ＝ { [ 9% &#x2F; ( 1 - 3% ) ] &#x2F; ( 1 - 25% ) } × 100% &#x3D; 12.37%</p>
<p>普通股资金的资金成本 ＝ [ 6% + 1.3 × ( 14% - 6% ) ] &#x2F; ( 1 - 25% ) × 100% &#x3D; 21.87%</p>
<p>② 计算各种资金的税前加权平均资金成本，即该信息化项目的基准收益率为：</p>
<p>i<sub>w</sub> &#x3D; 8.16% × ( 3000 &#x2F; 6000 ) + 12.37% × ( 2000 &#x2F; 6000 ) + 21.87% × ( 1000&#x2F;6000 ) &#x3D; 11.85%</p>
</li>
</ol>
</li>
</ol>
<h3 id="2-1-3-项目可行性研究"><a href="#2-1-3-项目可行性研究" class="headerlink" title="2.1.3 项目可行性研究"></a>2.1.3 项目可行性研究</h3><ol>
<li><p><strong>可行性研究概述</strong></p>
<p>可行性研究（ Feasibility Study ）是指项目投资之前，在深入调查研究的基础上，通过市场分析、财务分析、技术分析以及国民经济分析，对拟建项目的技术可行性与经济合理性的综合评价。</p>
<p>此外，可行性研究还是银行贷款、工程设计等的有力依据，是决策科学化的必要步骤。</p>
</li>
<li><p><strong>可行性研究的阶段</strong></p>
<p>项目的投资通常有投资前期、投资期以及生产期三个阶段。</p>
<p>其中，投资前期是决定项目效果的关键阶段，也是可行性研究的重点。</p>
<p>项目投资前期可分为投资机会研究、初步可行性研究、详细可行性研究（又称为可行性研究）、评估和投资决策四个阶段。</p>
<ol>
<li><strong>投资机会研究</strong></li>
<li><strong>初步可行性研究</strong></li>
<li><strong>详细可行性研究</strong></li>
<li><strong>评估和投资决策</strong></li>
</ol>
</li>
<li><p><strong>可行性研究的工作流程</strong></p>
<p>可行性研究的基本工作流程有<strong>签订委托协议</strong>、<strong>组建工作小组</strong>、<strong>制订工作方案</strong>、<strong>市场调查与预测</strong>、<strong>可行性方案研制与优化</strong>、<strong>项目评价</strong>和<strong>编写并提交可行性研究报告</strong>。</p>
</li>
<li><p><strong>可行性研究报告</strong></p>
<ol>
<li><p>可行性研究报告的作用</p>
<ol>
<li>作为经济主体投资决策的主要依据。</li>
<li>为筹资和向银行申请贷款的依据。</li>
<li>作为从国外引进技术、设备以及与国外厂商谈判签约的依据。</li>
<li>作为与项目协作单位（如项目分包）签订经济合同的依据。</li>
<li>作为向当地政府、相关部分申请有关建设许可文件的依据。</li>
<li>作为该项目基础设施建设的基础资料。</li>
<li>作为项目有关生产组织工作、职工培训等的依据。</li>
<li>作为对项目考核以及项目后评价的依据。</li>
</ol>
</li>
<li><p>项目可行性研究报告的编制要求</p>
<ol>
<li>要能充分反映项目可行性研究工作的成果，要内容齐全、数据准确、结论明确，以满足决策者确定方案和项目决策的要求。</li>
<li>信息资料必须满足时效性、可靠性及充足性的要求。</li>
<li>项目中选用的主要设备的规格、各项参数必须满足预定设备的要求。</li>
<li>可行性研究报告里的重大技术或者经济方案必须要有两个以上，以进行优选。</li>
<li>报告里确定的主要工程技术数据必须满足项目初步设计的要求。</li>
<li>对建设性投资与生产成本必须分项详细地估算，其误差要控制在士10％以内。</li>
<li>报告中所构造的融资筹资方案必须满足金融部门信贷决策的要求。</li>
<li>报告中要如实反映可行性研究过程中出现的某些方案的重大分歧或者未被采纳的原因，以便投资者能客观地权衡利弊并进行决策。</li>
<li>报告中应该附有评估、决策所必需的合同、意向书、协议以及政府批文等相关佐证材料。</li>
</ol>
</li>
<li><p>项目可行性研究报告的主要内容</p>
<p>项目可行性研究报告通常要求具备以下内容：</p>
<ol>
<li>项目总论：主要对拟建项目进行概括性的论述，包括项目提出的背景与概况、可行性研究工作的主要依据、研究结论的概要、项目所存在的问题和建议等。</li>
<li>市场预测：是项目可行性研究的重要环节，需要进行市场现状调查、产品的供需预测、价格预测、各种竞争力分析以及市场风险分析。</li>
<li>项目资源条件的评价：主要包括资源的开发价值、资源的品质及可利用情况等。</li>
<li>项目建设规模和产品方案：主要包括项目建设规模以及产品方案的构成及其比较和选择；推荐的项目建设规模和产品方案；技术改造类项目推荐方案及原企业设施利用的合理性。</li>
<li>场址选择：主要包括场址现状介绍及其方案比较和选择、推荐的场址方案介绍，对于技术改造类项目，应有场址利用情况的介绍。</li>
<li>技术方案、设备方案与工程方案的比较和选择。</li>
<li>主要原材料供应方案的比较和选择。</li>
<li>总体布置方案、场内外运输方案及供应辅助工程的情况。</li>
<li>节能措施分析。</li>
<li>节水措施分析。</li>
<li>环境影响评价：主要包括环境条件的调查、影响环境因素的分析、环境保护措施等。</li>
<li>劳动安全卫生与消防：主要包括危险因素及其危害程度的客观分析、相关安全防范措施、相关环保措施、技术改造类项目和原有企业环境状况的比较。</li>
<li>组织机构、人力资源配置以及项目员工的培训。</li>
<li>项目实施进度：主要包括项目建设的工期、项目实施进度的相关安排、技术改造类项目的建设与生产的相关衔接内容。</li>
<li>项目投资估算：主要包括项目投资估算的范围与依据、项目建设投资估算、流动资金的估算、项目总投入资金与分年投入的计划等。</li>
<li>融资方案：主要包括融资的组织形式，资本金、债务资金的筹措，融资方案的分析等。</li>
<li>财务评估：主要包括项目财务评价的基础数据和参数的选取、成本费用及销售收入的估算、财务评价报表、盈利及偿债能力分析、不确定因素分析、财务评价的结论等。</li>
<li>国民经济评价：主要包括国民经济评价报表、评价指标及评价结论等。</li>
<li>社会评价：主要包括项目对社会的影响、项目与所在地的相互适应性分析、社会风险分析以及社会评价结论。</li>
<li>风险分析：主要包括项目的主要风险识别、相关风险分析及风险防范对策。</li>
<li>研究结论与建议：主要包括推荐方案总体的描述、推荐方案优缺点的描述、主要对比方案介绍以及结论与建议。</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>市场调查</strong></p>
<ol>
<li><strong>市场调查的方法</strong><ol>
<li>文案调查法</li>
<li>访问调查法</li>
<li>观察调查法</li>
<li>实验调查法</li>
<li>网络调查法</li>
</ol>
</li>
<li><strong>市场预测的方法</strong><ol>
<li>消费者意图预测法</li>
<li>专家意见集合法</li>
<li>德尔菲法</li>
<li>经济计量模型预测法</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-1-4-成本与费用、销售收入与利润、主要税金"><a href="#2-1-4-成本与费用、销售收入与利润、主要税金" class="headerlink" title="2.1.4 成本与费用、销售收入与利润、主要税金"></a>2.1.4 成本与费用、销售收入与利润、主要税金</h3><ol>
<li><p><strong>成本与费用</strong></p>
<p>总成本费用是指软件工程在一定时期内，为生产和销售产品而花费的全部成本及其费用。</p>
<p>总成本费用主要有<strong>生产成本</strong>、<strong>经营成本</strong>和<strong>期间费用</strong>。</p>
<ul>
<li><p>生产成本</p>
<p>生产成本即生产费用或者制造成本，是指企业为了生产产品或者提供劳务所发生的各种资源耗费。</p>
<p>生产成本要素按照经济用途，可分为<strong>直接材料费</strong>（是指企业在生产过程中实际所耗费的直接材料、设备配件、辅助材料、燃料、包装物、外购半成品、低值易耗品、动力及其他直接材料）、<strong>直接工资费</strong>（又称为直接人工费，是指企业直接从事产品生产的工作人员的工资、津贴、奖金、补贴及福利等）、<strong>间接成本</strong>（又称为制造费用，如企业的分厂、车间管理人员、相关技术人员的工资及其福利，各种固定资产的维修费、物料消耗、水电费、修理期停工损失费等）以及<strong>其他直接支出</strong>。</p>
</li>
<li><p>经营成本</p>
<p>经营成本是软件工程经济学分析时需要从总成本费用中分离出来的一部分费用，是指 IT 企业在一定会计期间内由于生产、销售以及提供劳务所发生的费用。</p>
</li>
<li><p>期间费用</p>
<p>期间费用是指企业日常活动不能直接归属于某个特定成本核算对象，且在发生时应直接计入当期损益的各种费用。</p>
<p>期间费用包括<strong>管理费用</strong>、<strong>销售费用</strong>、<strong>财务费用</strong>和<strong>研发费用</strong>。</p>
<p>管理费用是指企业为了组织和管理企业的生产经营活动所发生的各项费用。管理费用主要包括单位经费、劳动保险费、工会经费、董事会费、业务招待费、技术转让费、无形资产摊销、住房公积金、职工教育经费、存货的盘亏或者盘盈、计提存货跌价准备、诉讼费、聘请中介机构费用、计提坏账准备等。</p>
<p>销售费用是指企业在销售产品或者提供劳务等经营过程中所发生的各项费用，主要包括企业为销售商品所设置的销售部门或机构的人员工资、办公费、职工福利费等，还有企业在销售过程中所发生的广告费、包装费、运输费、保险费、装卸费、展览费、委托代销费等。</p>
<p>财务费用是指企业为筹集生产经营所需资金而发生的各项费用，主要包括企业在生产经营活动中的利息支出净额（即利息支出减去利息收入之差）、汇兑净损失（即汇兑损失减去汇兑收益之差）、金融机构的相关手续费及其他费用等。</p>
<p>研发费用是指研究与开发某项目所支付的费用，主要包括研发活动直接消耗的材料、燃料和动力费用，研发人员的工资、津贴、奖金、补贴及福利等，以及用于研发活动的软件、专利权等无形资产的推销费用等。</p>
</li>
</ul>
</li>
<li><p><strong>销售收入与利润</strong></p>
<ol>
<li><p>销售收入</p>
<p>销售收入又称为营业收入，是指企业通过销售商品、提供劳务所获得的经济利益的总收入，即<br>$$<br>销售收入 &#x3D; 商品销售量 × 商品的单价<br>$$</p>
</li>
<li><p>营业外收入</p>
<p>营业外收入又称为营业外收益，是指和企业的生产经营活动没有直接关系，应计入当期利润的各种收入。</p>
<p>营业外收入是不需要耗费企业经营资金的，是一种纯收入。</p>
<p>营业外收人主要包括非货币性的资产交换利得、债务重组利得、非流动资产处置利得、出售无形资产收益、存货盘盈利得、企业合并损益、政府补助、罚款收入、教育费附加返还款以及捐赠利得等。</p>
</li>
<li><p>利润及其分配</p>
<p>利润是指企业在一定会计期间内所获得的经营成果。利润是企业销售商品所得收入扣除成本及税金后的余额，即<br>$$<br>利润 &#x3D; 销售收入-总成本费用-销售税金及附加<br>$$<br>其中，销售税金及附加是指与企业销售收入相关的税金及附加，主要包括营业税、资源税、消费税、城市维护建设税、教育费附加等税费。应交增值税不计入”主营业务及附加”。净利润又称为税后利润，是指在利润总额中缴纳了所得税后企业的利润留存。</p>
</li>
</ol>
</li>
<li><p><strong>主要税金</strong></p>
<p>根据纳税对象的不同，税收可分为所得税、资源税、流转税、农业税、财产行为税和关税。</p>
</li>
</ol>
<h2 id="2-2-资金的时间价值及其贴现与预算"><a href="#2-2-资金的时间价值及其贴现与预算" class="headerlink" title="2.2 资金的时间价值及其贴现与预算"></a>2.2 资金的时间价值及其贴现与预算</h2><h3 id="2-2-1-资金的时间价值"><a href="#2-2-1-资金的时间价值" class="headerlink" title="2.2.1 资金的时间价值"></a>2.2.1 资金的时间价值</h3><p>资金的时间价值是指<strong>资金经过一定时间的投资和再投资所产生的价值增加量</strong>。</p>
<ol>
<li><p><strong>利息</strong></p>
<p>利息是衡量资金时间价值的<strong>绝对衡量尺度</strong>。</p>
<p>利息的计算公式如下：<br>$$<br>I &#x3D; F - P<br>$$<br>式中，I 表示利息；F 表示还本付息总额；P 表示本金。</p>
</li>
<li><p><strong>利率</strong></p>
<p>利率是衡量资金时间价值的<strong>相对衡量尺度</strong>，又称为“利息率”。</p>
<p>下列公式乘以 100% 即为利率的计算公式：<br>$$<br>i &#x3D; \frac{I_t}{P}<br>$$<br>式中，i 表示利率；I<sub>t</sub> 表示单位时间内的利息；P 表示借款本金。</p>
</li>
<li><p><strong>单利</strong></p>
<p>单利（ Simple Interest ）是指仅仅以本金作为基数来计算利息，即不论年限有多长，每年都按原始本金计息，已取得的利息在后续年度不再计息的计息方法。</p>
<p>其计算公式如下所示：<br>$$<br>I_t &#x3D; P × i_d<br>$$<br>式中，I<sub>t</sub> 表示第 t 期的利息额度；P 表示本金；i<sub>d</sub> 表示计息单利利率。</p>
</li>
<li><p><strong>复利</strong></p>
<p>复利（ Compound Interest ）是指计算利息时以本金和累计利息和作为基数的计息方法，即“利生利”的计息方法。</p>
<p>其计算公式如下所示：<br>$$<br>I_t &#x3D; i × F_{t-1}<br>$$<br>式中，I<sub>t</sub> 表示第 t 期的利息额度；i 表示计息期的利率；F<sub>t-1</sub> 表示第 t-1 年年末的复利本利和。</p>
<p>由此可推导出第 t 年年末复利和的计算公式：<br>$$<br>F_t &#x3D; F_{t-1} × (1+i)<br>$$</p>
</li>
</ol>
<h3 id="2-2-2-现金流量的内涵"><a href="#2-2-2-现金流量的内涵" class="headerlink" title="2.2.2 现金流量的内涵"></a>2.2.2 现金流量的内涵</h3><ol>
<li><p><strong>现金流量的概念</strong></p>
<p>现金流量（ Cash Flows , CF ）是指特定经济系统（某个项目、企业、地区或部门）在某一时点发生了所有权或使用权转移的现金或其等价物（如银行承兑汇票、短期国库券、可转让定期存单等）的数量。软件工程经济学中的现金流量是指拟建设项目在整个项目计算期内各个时点上实际发生的现金流入、流出以及流入和流出的差额。</p>
<p>现金流入（ Cash Inflows , CI ）是指流入特定经济系统的现金。如 IT 企业销售商品或提供劳务等获得的现金、从银行获得的借款等都属于现金流入。现金流出（ Cash Outflows , CO ）是指流出特定经济系统的现金，如企业购买固定资产、租赁设备、偿还债务等支付的现金。同一时点上的现金流入和流出之差称为净现金流量，通常用 CI - CO 表示。</p>
<p>净现金流量分为正现金流量和负现金流量。</p>
<p>正现金流量是指一定时期的净收入，负现金流量是指一定时期的净支出。</p>
</li>
<li><p><strong>现金流量的分类</strong></p>
<p>在现金流量表中，通常将现金流量分为以下三大类：</p>
<ol>
<li>经营活动产生的现金流量</li>
<li>投资活动产生的现金流量</li>
<li>筹资活动产生的现金流量</li>
</ol>
</li>
<li><p><strong>软件企业确定现金流量需要注意的问题</strong></p>
<ol>
<li>对于每一笔现金流入和流出都要有明确的发生时点。</li>
<li>现金流量必须是企业实际发生的，且每一笔现金流量都必须有可靠的凭证作为验证，不应将应收账款、应付账款、暂时不能兑现的有价证券以及不能立即出让的固定资产账面价值等记入现金流量。</li>
<li>同一个软件工程项目或者集成项目的现金流量，因立场及出发点不同会产生不同的结果。例如，某软件工程项目的投资方和承建方是不同的两个单位，当投资方支付项目款给承建方时，对于投资方而言是现金流出，而对于承建方而言则是现金流人。</li>
<li>所有权或者使用权未发生转移的现金，其等价物不是现金流量。例如，企业的固定资产在未被使用之前不能将固定资产折旧列入现金流量。</li>
</ol>
</li>
<li><p><strong>现金流量图</strong><br>现金流量图（ Cash - Flows Diagrams ）是指<strong>在时间坐标轴上，用带箭头的短线表示一个建设项目或者一个企业资金活动规律的图形。</strong></p>
<p>软件企业可以依据现金流量图来考察软件工程项目或者系统集成项目在其整个生命周期内每个阶段的资金变化情况，进而分析其经济效果。</p>
</li>
<li><p><strong>现金流量的作用</strong></p>
<p>现金流量的作用主要体现在以下三个方面：</p>
<ol>
<li>能对软件企业获取现金的能力作出评估。</li>
<li>能对软件企业的偿债能力作出评价。</li>
<li>能对软件工程项目收益的质量及投资、筹资活动作出评价。</li>
</ol>
</li>
</ol>
<h3 id="2-2-3-资金等值的计算及其应用"><a href="#2-2-3-资金等值的计算及其应用" class="headerlink" title="2.2.3 资金等值的计算及其应用"></a>2.2.3 资金等值的计算及其应用</h3><ol>
<li><p><strong>资金等值</strong></p>
<p>资金具有时间价值。</p>
<p>在软件工程项目中，资金的等值计算所涉及的概念有：</p>
<ul>
<li><p><strong>贴现（ Discount ）和贴现率（ Discount Rate )：</strong>贴现又称为折现，是指把将来某个时点的资金金额换算成现在时点的等值金额：贴现率是指贴现时所使用的利率（ i )，又称为折现率。</p>
</li>
<li><p><strong>现值 P ( Present Value )：</strong>是指资金贴现到现在时刻的价值。现值是一个相对的概念，如将 t + n 个时点上所发生的资金折现到第1个时点，所得的等值金额就是 t + n 个时点上的资金额在 t 时点的现值。</p>
</li>
<li><p><strong>终值 F ( Future Value )：</strong>又称为将来值或未来值，是指计息期期末的资金价值，或者表示现在某个时点的资金价值在未来某个时点的资金价值。</p>
</li>
<li><p><strong>年金 A ( Annual Value )：</strong>又称为年值或等额年值，是指每期都发生的等额现金流的金额，如租金、利息、折旧、保险金等。</p>
<p>年金又分为<strong>普通年金</strong>、<strong>预付年金</strong>和<strong>延期年金</strong>三种。普通年金又称为后付年金，是指每期期末收、付款的现金流量序列，是最常用的年金形式；预付年金是指每期期初收、付款的现金流量序列；而延期年金是指距今若干期以后所发生的每期期末收、付款的现金流量序列。</p>
</li>
</ul>
</li>
<li><p><strong>资金等值的计算</strong></p>
<ol>
<li><p><strong>一次性支付复利终值公式（已知 P，求 F ）</strong></p>
<p>n 年末的本利和 F 与本金 P 的关系如下公式所示：<br>$$<br>F &#x3D; P(1+i)^n<br>$$</p>
<p>式中，( 1+i )<sup>n</sup> 称为<strong>复利终值系数</strong>。</p>
<p>【例2.9】某软件企业向银行贷款 100 万元，按年利率 8% 进行复利计息，试求该企业第 4 年年末连本带利一次偿还银行的金额，并画出其现金流量图。</p>
<p>解：</p>
<p>根据题意可得：<br>$$<br>F &#x3D; P (1+i)^n &#x3D; 100 × (1+0.08)^4 &#x3D; 100 × 1.3605 &#x3D; 136.05（万元）<br>$$<br>现金流量图如下所示：</p>
<p><img src="https://s1.ax1x.com/2023/06/02/pCpCgmD.jpg" alt="例2.9现金流量图"></p>
</li>
<li><p><strong>一次性支付复利现值公式（已知 F，求 P ）</strong></p>
<p>由上述公式可求出现值 P，如下公式所示：<br>$$<br>P &#x3D; F(1+i)^{-n}<br>$$<br>式中，( 1+i )<sup>-n</sup> 称为<strong>复利现值系数</strong>。</p>
<p>【例2.10】某软件企业希望通过某信息化项目投资在第 4 年年末得到 200 万元的资金，若按年利率为 8% 进行复利计息，该企业需要一次性投入多少资金？</p>
<p>解：</p>
<p>根据题意可得：<br>$$<br>P &#x3D; F(1+i)^{-n} &#x3D; 200 × (1+0.08)^{-4} &#x3D; 200 × 0.735 &#x3D; 147（万元）<br>$$</p>
</li>
<li><p><strong>等额支付终值公式（又称为年金终值公式，已知 A，求 F ）</strong></p>
<p>对于某个软件工程项目相应的经济系统，在其每个计息周期的期末（不含第 0 期）都支付相同数额的 A，在年利率为 i 时，求该系统 n 年后的终值，即等额支付终值的计算问题，其现金流量图如下所示：</p>
<p><img src="https://s1.ax1x.com/2023/06/02/pCpiKGn.jpg" alt="等额支付终值现金流量图"></p>
<p>根据等比数列的求和公式可推导出下列公式：<br>$$<br>F &#x3D; A \frac{(1+i)^n-1}{i}<br>$$</p>
<p>上述公式即为<strong>等额支付终值公式</strong>。</p>
<p>【例2.11】某企业软件在 6 年内，每年年末存入银行 200 万元，按年利率均为 6% 的复利计算，在第 6 年年末该企业可以连本带利取出多少资金？</p>
<p>解：</p>
<p>根据题意可得：<br>$$<br>F &#x3D; A \frac{(1+i)^n-1}{i} &#x3D; 200 × \frac{(1+0.06)^6-1}{0.06} &#x3D; 200 × 6.9753 &#x3D; 1395.06（万元）<br>$$</p>
</li>
<li><p><strong>等额支付偿债基金公式（已知 F，求 A ）</strong></p>
<p>等额支付偿债基金的计算是等额支付终值计算的逆运算。已知当年利率为 i，求 n 年年末的资金 F 换算为与其等值的 n 年中每年年末的等额资金 A，即为偿债基金的计算问题。</p>
<p>等额支付偿债基金公式如下：<br>$$<br>A &#x3D; F \frac{i}{(1+i)^n-1}<br>$$<br>【例2.12】某 ERP 企业计划自筹资金在 6 年后获得 500 万元资金进行某新技术开发，依据市场行情，银行利率为 6%，则从今年开始每年年末应筹集多少资金存入银行？</p>
<p>解：</p>
<p>根据题意可得：<br>$$<br>A &#x3D; F \frac{i}{(1+i)^n-1} &#x3D; 500 × \frac{0.06}{(1+0.06)^6-1} &#x3D; 500 × 0.1434 &#x3D; 71.7（万元）<br>$$</p>
</li>
<li><p><strong>等额支付现值公式（又称为年金现值公式，已知 A，求 P ）</strong></p>
<p>等额支付现值公式如下：<br>$$<br>P &#x3D; F(1+i)^{-n} &#x3D; A \frac{(1+i)^n-1}{i}·(1+i)^{-n} &#x3D; A\frac{(1+i)^n-1}{i(1+i)^{n}}<br>$$<br>【例2.13】假设某 IT 企业期望在 8 年时间内每年年末能从银行取回 200 万元，如果按 6% 的复利计息，则该企业现在需要存入银行多少资金？</p>
<p>解：</p>
<p>根据题意可得：<br>$$<br>P &#x3D; A\frac{(1+i)^n-1}{i(1+i)^{n}} &#x3D; 200 × \frac{(1+0.06)^8-1}{0.06(1+0.06)^{8}} &#x3D; 200 × 6.2098 &#x3D; 1241.96（万元）<br>$$</p>
</li>
<li><p><strong>等额支付资金回收公式（已知 P，求 A ）</strong></p>
<p>等额支付资金回收的计算是等额支付现值公式的逆运算。<br>$$<br>A &#x3D; P\frac{i(1+i)^{n}}{(1+i)^n-1}<br>$$<br>【例2.14】某 IT 企业向银行贷款 3500 万元投入某项目建设，按年利率 8% 的复利计算，若在 6 年内每年年末按等额还款的方式，则每年年末应还款的资金是多少？</p>
<p>解：</p>
<p>根据题意可得：<br>$$<br>A &#x3D; P\frac{i(1+i)^{n}}{(1+i)^n-1} &#x3D; 3500 × \frac{0.08(1+0.08)^{6}}{(1+0.08)^6-1} &#x3D; 3500 × 0.2163 &#x3D; 757.05（万元）<br>$$</p>
</li>
</ol>
</li>
</ol>
<h2 id="2-3-招标与投标"><a href="#2-3-招标与投标" class="headerlink" title="2.3 招标与投标"></a>2.3 招标与投标</h2><p>软件工程类项目的经费来源一般分为三类：</p>
<p>第一类：国家、省级自然基金，国家信息化工程及国防科研基金项目；</p>
<p>第二类：企业自行筹资项目；</p>
<p>第三类：经过投标竞争获取的企业或政府部门招标项目。本节将介绍第三类项目有关软件招标与投标的法律法规相关内容。</p>
<h3 id="2-3-1-招标、投标概述"><a href="#2-3-1-招标、投标概述" class="headerlink" title="2.3.1 招标、投标概述"></a>2.3.1 招标、投标概述</h3><p>依据《中华人民共和国招标投标法》《中华人民共和国招标投标法实施条例《国家发展计划委工程建设项目招标范围和规模标准规定》（国家发展计划委令第3号）以及《国家发展改革委必须招标的工程项目规定》（国家发展改革委令第16号）相关要求，下列工程建设项目的勘察、设计、施工、监理以及建设有关的重要设备、材料等的采购，必须进行招标：</p>
<ol>
<li>大型基础设施、公用事业等关系社会公共利益、公众安全的项目；</li>
<li>全部或部分使用国有资金投资或者国家融资的项目；</li>
<li>使用国际组织或者外国政府贷款、援助资金的项目。</li>
</ol>
<p>任何单位与个人都不得将依法必须进行招标的项目化整为零或者以其他任何方式规避招标。招标、投标活动应当遵循公开、公平、公正和诚实信用的原则。依法必须进行招标的项目，其招标、投标活动不受地区或者部门的限制。任何单位和个人不得违法限制或者排斥本地区、本系统以外的法人或者其他组织参加投标，不得以任何方式非法干涉招标、投标活动。</p>
<h3 id="2-3-2-招标人及其权利与义务"><a href="#2-3-2-招标人及其权利与义务" class="headerlink" title="2.3.2 招标人及其权利与义务"></a>2.3.2 招标人及其权利与义务</h3><p>招标人是依照《中华人民共和国招标投标法》规定提出招标项目、进行招标的法人或者其他组织。招标人应该有进行招标项目的相应资金或者资金来源已经落实，并应该在招标文件中如实载明。</p>
<ol>
<li><strong>招标人的权利</strong><ol>
<li>招标人可自行办理招标事宜，也可自行选择招标代理机构，委托其办理招标事宜；</li>
<li>招标人可根据招标项目本身的要求，在招标公告或投标邀请书中要求潜在投标人提供相关资质文件和业绩情况，并对潜在投标人进行资格审查；</li>
<li>招标人可对已发出的资格预审文件或者招标文件进行必要的澄清或者修改；</li>
<li>招标人有权拒收在招标文件要求提交的截止时间后送达的投标文件。</li>
</ol>
</li>
<li><strong>招标人的义务</strong><ol>
<li>招标人委托招标代理机构时，应向其提供招标所需的全部相关资料并支付委托费；</li>
<li>招标人不得以不合理条件限制或者排斥潜在投标人，不得对潜在投标人实行歧视待遇；</li>
<li>招标文件不得要求或者标明特定的生产供应者，以及含有倾向或者排斥潜在投标人的内容；</li>
<li>招标人不得向他人透露已获取招标文件的潜在投标人的名称、数量，以及可能影响公平竞争的有关招标投标的其他情况；</li>
<li>招标人应当明确投标人编制投标文件所需要的合理时间，最短不得少于20日；</li>
<li>在招标文件要求提交投标文件的截止时间前收到的所有投标文件，开标时都应当众拆封与宣读；</li>
<li>招标人应当采取必要的措施，保证评标在严格保密的情况下进行；</li>
<li>在确定中标人后，招标人应当向中标人发出中标通知书，并同时将中标结果通知所有未中标的投标人；</li>
<li>招标人与中标人应当自中标通知书发出之日起30日内，按照招标文件和中标的投标文件签订书面合同。</li>
</ol>
</li>
</ol>
<h3 id="2-3-3-招标代理机构及其权利与义务"><a href="#2-3-3-招标代理机构及其权利与义务" class="headerlink" title="2.3.3 招标代理机构及其权利与义务"></a>2.3.3 招标代理机构及其权利与义务</h3><p>招标代理机构是依法设立、从事招标代理业务并提供相关服务的社会中介组织，与行政机关和其他国家机关不得存在隶属关系或者其他利益关系，应该具备从事招标代理业务的营业场所与相应资金，必须要有能够编制招标文件以及组织评标的相应专业力量。</p>
<ol>
<li><strong>招标代理机构的权利</strong><ol>
<li>组织和参与招标活动；</li>
<li>依据招标文件规定，审查投标人的资质；</li>
<li>按规定标准收取招标代理费。</li>
</ol>
</li>
<li><strong>招标代理机构的义务</strong><ol>
<li>维护招标人和投标人的合法利益；</li>
<li>组织编制和解释招标文件；</li>
<li>接受国家招标、投标管理机构等有关行政监督部门的指导、监督；</li>
<li>应当在招标人委托的招标范围内办理招标事宜，并遵守《中华人民共和国招标投标法》关于招标人的规定。</li>
</ol>
</li>
</ol>
<h3 id="2-3-4-招标、投标的基本特性与基本原则"><a href="#2-3-4-招标、投标的基本特性与基本原则" class="headerlink" title="2.3.4 招标、投标的基本特性与基本原则"></a>2.3.4 招标、投标的基本特性与基本原则</h3><ol>
<li><strong>招标、投标工作的基本特性</strong><ol>
<li>招标、投标的公平竞争。</li>
<li>招标、投标的交易规范。</li>
<li>招标、投标的一次机会。</li>
<li>招标、投标的定制方案特性。</li>
<li>招标、投标的复合职业特性。</li>
</ol>
</li>
<li><strong>招标、投标工作的基本原则</strong><ol>
<li>公开原则</li>
<li>公平原则</li>
<li>公正原则</li>
<li>诚实信用原则</li>
</ol>
</li>
</ol>
<h3 id="2-3-5-招标的方式"><a href="#2-3-5-招标的方式" class="headerlink" title="2.3.5 招标的方式"></a>2.3.5 招标的方式</h3><p>招标分为<strong>公开招标</strong>和<strong>邀请招标</strong>。</p>
<p>公开招标是指<strong>招标人以招标公告的方式邀请不特定的法人或者其他组织投标。</strong></p>
<p>邀请招标是指<strong>招标人以投标邀请书的方式邀请特定的法人或者其他组织投标。</strong></p>
<p>国有资金占控股或者主导地位的依法必须进行招标的项目，应当公开招标；但有下列情况之一的，可以邀请招标：</p>
<ol>
<li>技术复杂、有特殊要求或者受自然环境限制，只有少量潜在投标人可供选择；</li>
<li>采用公开招标方式的费用占项目合同金额的比例过大。</li>
</ol>
<p>招标人采用公开招标方式的，应当发布招标公告。依法进行招标项目的招标公告，应当通过国家指定的报刊、信息网络或者其他媒介发布。招标公告应当载明招标人的名称和地址，招标项目的性质、数量、实施地点和时间以及获取招标文件的办法等相关事项。</p>
<p>招标人采用邀请招标方式的，应当向三个及以上具备承担所招标项目的能力、资信良好的特定的法人或者其他组织发出投标邀请书。投标邀请书应当载明的事项必须与公开招标公告规定的事项要求完全一致。</p>
<p><strong>公开招标和邀请招标的区别：</strong></p>
<ol>
<li>发布信息的方式不同。</li>
<li>选择的范围不同。</li>
<li>竞争的范围不同。</li>
<li>公开的程度不同。</li>
<li>时间与费用不同。</li>
</ol>
<h3 id="2-3-6-投标"><a href="#2-3-6-投标" class="headerlink" title="2.3.6 投标"></a>2.3.6 投标</h3><p>投标人是响应招标、参加投标竞争的法人或者其他组织，依法招标的科研项目也可允许个人参与投标。</p>
<p>投标人与招标人存在利害关系，如可能影响招标公正性的法人、其他组织或者个人，不得参与投标。</p>
<p>投标人的义务有：</p>
<ol>
<li>投标人应当按照招标文件的要求编制投标文件。投标文件应当对招标文件提出的实质性要求与条件做出实质性响应。</li>
<li>投标人应当在招标文件要求提交投标文件的截止时间前，将投标文件送达招标文件指定的投标地点。</li>
<li>投标人可以在招标文件要求的提交投标文件截止时间前，补充、修改或撤回已提交的投标文件，并书面通知招标人。</li>
<li>投标人根据招标文件载明的项目实际情况，拟在中标后将中标项目的部分非主体、非关键性工作进行分包的，应当在投标文件中载明。</li>
</ol>
<h3 id="2-3-7-开标、评标和中标"><a href="#2-3-7-开标、评标和中标" class="headerlink" title="2.3.7 开标、评标和中标"></a>2.3.7 开标、评标和中标</h3><ol>
<li><p><strong>开标</strong></p>
<p>开标原则上应当在招标文件规定的提交投标文件截止时间的同一时间公开进行；开标地点必须是招标文件中预先规定的地点。开标由招标人主持，邀请所有投标人参加。开标时，由投标人或者其推选的代表检查投标文件密封情况，也可以由招标人委托的公证机构检查并进行公证；经确认无误后，由工作人员当众拆封，并宣读投标人名称、投标价格与投标文件的其他主要内容。招标人在招标文件要求提交投标文件的截止时间前收到的所有投标文件，开标时都应该当众予以拆封和宣读。开标过程必须作好记录，并存档备查。</p>
</li>
<li><p><strong>评标</strong></p>
<p>评标工作由招标人依法组建的评标委员会负责。依法必须进行招标的软件工程项目，其评标委员会由招标人的代表以及相关技术、经济等方面的专家组成，成员人数为五人以上单数，其中技术、经济等方面的专家不得少于评标成员总人数的三分之二。评标委员会专家资质应依据《中华人民共和国招标投标法》有关条款来确定。</p>
<p>评标委员会可以要求投标人对投标文件中含义不明确的内容作必要的澄清或说明，但是澄清或说明不得超出投标文件的范围或改变投标文件的实质性内容。<br>评标委员会应当按照招标文件确定的评标标准和方法，对投标文件进行评审和比较；设有标底的，应当参考标底。评标委员会完成评标后，应当向招标人提出书面评标报告，并推荐合格的候选中标人。招标人根据评标委员会提出的书面评标报告与所推荐的中标候选人确定中标人，也可以授权评标委员会直接确定中标人。</p>
<p>中标人的投标应当符合下列条件之一：</p>
<ol>
<li><p>能够最大限度地满足招标文件中规定的各项综合评价标准；</p>
</li>
<li><p>能够满足招标文件的实质性要求，并且经评审的投标价格最低，但是投标价格低于成本的除外。少数软件工程项目的投资方为了保证项目的质量，采用价格按所有投标方报价的算术平均值作为最高分的，必须按招标文件中明确的评分标准计算。</p>
<p>评标委员会经评审，如果认为所有投标方全都不符合招标文件要求的，可以否决所有投标。</p>
</li>
</ol>
</li>
<li><p><strong>中标</strong></p>
<p>中标人确定后，招标人应当向中标人发出中标通知书，并同时将中标结果通知所有未中标的投标人。中标通知书对招标人和中标人具有同等法律效力。中标通知书发出后，招标人改变中标结果的，或者中标人放弃中标项目的，应当依法承担法律责任。</p>
<p>招标人和中标人应当自中标通知书发出之日起三十日内，按照招标文件与中标人的投标文件的合同约定签订书面合同。招标人与中标人不得再行订立背离合同实质性内容的其他协议。招标文件要求中标人提交履约保证金的，中标人必须按招标文件的要求提交，履约保证金不得超过中标合同金额的 10%。</p>
</li>
</ol>
<h3 id="2-3-8-招标、投标的程序"><a href="#2-3-8-招标、投标的程序" class="headerlink" title="2.3.8 招标、投标的程序"></a>2.3.8 招标、投标的程序</h3><p>尽管招标方式不同，但招投标的程序基本相同，一般要经过<strong>确定采购需求与招标方式</strong>、<strong>发布招标公告或投标邀请书</strong>、<strong>编制投标文件</strong>、<strong>递交投标文件</strong>、<strong>开标</strong>、<strong>评标</strong>、<strong>确定中标人</strong>以及<strong>签订合同</strong>的流程。</p>
<h3 id="2-3-9-招标、投标的法律责任"><a href="#2-3-9-招标、投标的法律责任" class="headerlink" title="2.3.9 招标、投标的法律责任"></a>2.3.9 招标、投标的法律责任</h3><p>法律责任是指违法者对违法行为所应承担的具有强制性的法律责任。</p>
<p>在《中华人民共和国招投标法》中明确了招标过程中各方的法律责任，涉及招标人、招标代理机构、投标人、评标委员会成员、中标人、有关行政监督部门等。</p>
<p>就投标人承担的法律责任来说，具体规定如下：</p>
<ol>
<li>投标人相互串通投标或者与招标人串通投标的，投标人以向招标人或者评标委员会成员行贿的手段谋取中标的，中标无效，并处以中标项目金额千分之五以上千分之十以下的罚款，对单位直接负责的主管人员和其他直接责任人员处以中标项目金额百分之五以上百分之十以下的罚款；有违法所得的，没收违法所得；情节严重的，取消其一至二年内参加投标的资格并予以公告，直至由工商行政管理机关吊销营业执照；构成犯罪的，依法追究刑事责任；给他人造成损失的，依法承担赔偿责任。</li>
<li>投标人以他人名义投标或者以其他方式弄虚作假骗取中标的，中标无效；给招标人造成损失的，依法承担赔偿责任；构成犯罪的，依法追究刑事责任。</li>
</ol>
<h3 id="2-3-10-软件工程项目投标文件的案例"><a href="#2-3-10-软件工程项目投标文件的案例" class="headerlink" title="2.3.10 软件工程项目投标文件的案例"></a>2.3.10 软件工程项目投标文件的案例</h3><p>软件工程项目投标文件的内容包括两大部分：</p>
<p>第一部分是投标人的相关材料，包括从事软件工程项目的研究经历（合同书、鉴定、评审意见书、获奖证明、市场销售量、相关部门的效益评价书等）；技术水平（通信系统、计算机软硬分析设计、测试人才数量、主要技术人员的职称证明文件、从事相关项目研究经历等）；信息资源拥有量；资金与财务状况的银行、会计、审计部门证明文件；企业管理人员简历以及履约能力证明文件等。</p>
<p>第二部分是软件工程项目的技术设计文件。</p>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章 软件的成本管理与定价分析</title>
    <url>/posts/a0090003.html</url>
    <content><![CDATA[<h2 id="3-1-软件的成本构成及其影响因素"><a href="#3-1-软件的成本构成及其影响因素" class="headerlink" title="3.1 软件的成本构成及其影响因素"></a>3.1 软件的成本构成及其影响因素</h2><p>软件成本是指软件工程项目从设计到软件产品或软件工程项目完成期间所需费用的总和。</p>
<p>成本的分类方法一般可以按照不同的准则进行划分：</p>
<ol>
<li><strong>按照企业的主要经营活动</strong>可分为采购成本、研究与开发成本、生产成本、经营成本以及管理费用。</li>
<li><strong>按照生产费用计入成本</strong>的方法，可分为直接成本和间接成本。</li>
<li><strong>按照成本与所完成项目工作量的关系</strong>，可分为固定成本和变动成本。</li>
<li><strong>按照成本所确定的时间</strong>，可分为预算成本、计划成本及实际成本。</li>
</ol>
<h3 id="3-1-1-软件工程项目的成本构成"><a href="#3-1-1-软件工程项目的成本构成" class="headerlink" title="3.1.1 软件工程项目的成本构成"></a>3.1.1 软件工程项目的成本构成</h3><p>软件成本是软件在其生存周期内为取得各种软、硬件资源的支持以及维持系统的研究、生产经营及管理工作所支付的所有费用。</p>
<p>软件工程项目成本又称为软件工程项目支出，是指为了实现软件工程项目目标所耗用资源的成本总和。软件工程项目成本主要由<strong>硬件成本</strong>、<strong>软件开发成本</strong>、<strong>人员培训费用</strong>和<strong>项目管理费用</strong>等构成。</p>
<p>软件工程项目成本主要涉及以下 15 类：</p>
<ol>
<li>调研费用</li>
<li>环境建设费用</li>
<li>工具购置费</li>
<li>基建费用</li>
<li>软件开发&#x2F;测试费用</li>
<li>人力资源费用</li>
<li>水、电、运输费</li>
<li>第三方评测费</li>
<li>软件产品制作费用</li>
<li>培训费用</li>
<li>现场实施费用</li>
<li>营销费用</li>
<li>售后服务运行维护费</li>
<li>管理费用</li>
<li>其他费用</li>
</ol>
<h3 id="3-1-2-软件成本测算的影响因素"><a href="#3-1-2-软件成本测算的影响因素" class="headerlink" title="3.1.2 软件成本测算的影响因素"></a>3.1.2 软件成本测算的影响因素</h3><h3 id="3-1-3-软件成本测算的流程"><a href="#3-1-3-软件成本测算的流程" class="headerlink" title="3.1.3 软件成本测算的流程"></a>3.1.3 软件成本测算的流程</h3><h2 id="3-2-软件的成本核算"><a href="#3-2-软件的成本核算" class="headerlink" title="3.2 软件的成本核算"></a>3.2 软件的成本核算</h2><p>对软件工程项目的成本与工期测算的方法较多，通常有功能分解法、统计模型法、价值工程法、表格法、驱动因子法、计算机模拟法、类比法、专门成本测算工具软件预算等方法。</p>
<p>以下主要分析<strong>驱动因子法</strong>和<strong>类比法</strong>。</p>
<h3 id="3-2-1-功能分解法"><a href="#3-2-1-功能分解法" class="headerlink" title="3.2.1 功能分解法"></a>3.2.1 功能分解法</h3><p>功能分解法主要从结构上将软件系统按照功能或者性能与生存周期各阶段进行二维分解。</p>
<h3 id="3-2-2-驱动因子法"><a href="#3-2-2-驱动因子法" class="headerlink" title="3.2.2 驱动因子法"></a>3.2.2 驱动因子法</h3><p>驱动因子法又称为影响因子法，是一种在统计模型的基础上通过引入更多对 y 有影响的要素，来完成统计模型估计值的修正的一种定性与定量相结合的方法。</p>
<ol>
<li><p><strong>驱动因子法的求解方法</strong></p>
<ol>
<li><p>确定对因变量 y 做出估计的统计模型 y&#x3D;g(x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>)，其中x<sub>j</sub>（1~n）是指通过定量估算法求得的对 y 有较大影响的几个要素。</p>
</li>
<li><p>引入综合要素 U，U 是指除了 x<sub>j</sub> 以外对 y 有影响的估计值，如下列公式所示：<br>$$<br>y &#x3D; U · g(x_{1},x_{2},…,x_{n})<br>$$</p>
<p>$$<br>U &#x3D; \prod_{j&#x3D;1}^{n} U_{j}<br>$$</p>
</li>
</ol>
</li>
<li><p><strong>影响要素引入 x<sub>j</sub> （1~n）的基本原则</strong></p>
<ol>
<li>对 y 有重要影响的要素归入 x<sub>j</sub>，其他归入 U<sub>j</sub>。</li>
<li>易于定量的影响要素归入 x<sub>j</sub>，不易于定量的影响要素归入 U<sub>j</sub>。</li>
<li>x<sub>j</sub> 的数量不宜太多，否则求解统计模型较困难。</li>
</ol>
</li>
<li><p><strong>结构化成本模型</strong></p>
<p>结构化成本模型（ COCOMO ）主要有基本模型、中级模型和详细模型三种。</p>
<p>中级模型适用于系统规划阶段作软件成本估算的模型，其求解方式如下列公式所示：<br>$$<br>C_{s} &#x3D; a · M_{s}<br>$$</p>
<p>$$<br>T_{d} &#x3D; h(M_{s})^d<br>$$</p>
<p>$$<br>M_{s} &#x3D; U · M_{0}<br>$$</p>
<p>$$<br>M_{0} &#x3D; r · L^{k}<br>$$</p>
<p>$$<br>U &#x3D; \prod_{j&#x3D;1}^{15} U_{j}<br>$$</p>
</li>
</ol>
<p><strong>中级 COCOMO 变量参数明细表如下。</strong></p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">变量名称</th>
<th align="center">经济含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">C<sub>s</sub></td>
<td align="center">软件开发成本</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">a</td>
<td align="center">软件开发阶段的工时费用率</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">M<sub>s</sub></td>
<td align="center">软件开发阶段的修正工作量</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">M<sub>0</sub></td>
<td align="center">软件开发阶段的基本工作量</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">L</td>
<td align="center">软件开发规模</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">U</td>
<td align="center">软件综合影响要素</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">U<sub>j</sub></td>
<td align="center">对成本有一定影响的第 j 个影响要素</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">T<sub>d</sub></td>
<td align="center">工期（开发周期）</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">r，k，h，d</td>
<td align="center">形式参数</td>
</tr>
</tbody></table>
<p><strong>中级 COCOMO 形式参数明细表如下。</strong></p>
<table>
    <thead>
        <tr align="center">
            <th rowspan="2">软件总体类型</th>
            <th colspan="2">基本工作量 M<sub>0</sub></th>
            <th colspan="2">开发工期 T<sub>d</sub></th>  
        </tr>
        <tr align="center">
            <td>r</td>
            <td>k</td>
            <td>h</td>
            <td>d</td>
        </tr>
    </thead>
    <tbody>
        <tr align="center">
            <td>有机型</td>
            <td>3.2</td>
            <td>1.05</td>
            <td>2.5</td>
            <td>0.38</td>
        </tr>
        <tr align="center">
            <td>嵌入型</td>
            <td>2.8</td>
            <td>1.20</td>
            <td>2.5</td>
            <td>0.32</td>
        </tr>
        <tr align="center">
            <td>半独立型</td>
            <td>3.0</td>
            <td>1.12</td>
            <td>2.5</td>
            <td>0.35</td>
        </tr>
    </tbody>
</table>


<p><strong>中级 COCOMO 工作量影响因素等级明细表如下。</strong></p>
<table>
    <thead>
        <tr align="center">
            <th colspan="2">工作量影响要素 U</th>
            <th>非常低</th>
            <th>低</th>
            <th>正常</th>
            <th>高</th>
            <th>非常高</th>
            <th>超高</th>
        </tr>
    </thead>
    <tbody>
        <tr align="center">
            <td rowspan="3">产品因素类</td>
            <td>软件可靠性 U<sub>1</sub></td>
            <td>0.75</td>
            <td>0.88</td>
            <td>1.00</td>
            <td>1.15</td>
            <td>1.40</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>数据库规模 U<sub>2</sub></td>
            <td>-</td>
            <td>0.94</td>
            <td>1.00</td>
            <td>1.08</td>
            <td>1.16</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>产品复杂性 U<sub>3</sub></td>
            <td>0.70</td>
            <td>0.85</td>
            <td>1.00</td>
            <td>1.15</td>
            <td>1.30</td>
            <td>1.65</td>
        </tr>
        <tr align="center">
            <td rowspan="4">计算机因素类</td>
            <td>执行时间限制 U<sub>4</sub></td>
            <td>-</td>
            <td>-</td>
            <td>1.00</td>
            <td>1.10</td>
            <td>1.30</td>
            <td>1.65</td>
        </tr>
        <tr align="center">
            <td>主存储限制 U<sub>5</sub></td>
            <td>-</td>
            <td>-</td>
            <td>1.00</td>
            <td>1.06</td>
            <td>1.21</td>
            <td>1.65</td>
        </tr>
        <tr align="center">
            <td>易变性 U<sub>6</sub></td>
            <td>-</td>
            <td>0.87</td>
            <td>1.00</td>
            <td>1.15</td>
            <td>1.30</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>环境周转时间 U<sub>7</sub></td>
            <td>-</td>
            <td>0.87</td>
            <td>1.00</td>
            <td>1.07</td>
            <td>1.15</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td rowspan="5">人员因素类</td>
            <td>分析员能力 U<sub>8</sub></td>
            <td>1.46</td>
            <td>1.19</td>
            <td>1.00</td>
            <td>0.86</td>
            <td>0.71</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>应用领域实际经验 U<sub>9</sub></td>
            <td>1.29</td>
            <td>1.13</td>
            <td>1.00</td>
            <td>0.91</td>
            <td>0.82</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>程序员能力 U<sub>10</sub></td>
            <td>1.42</td>
            <td>1.17</td>
            <td>1.00</td>
            <td>0.86</td>
            <td>0.70</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>使用经验 U<sub>11</sub></td>
            <td>1.21</td>
            <td>1.10</td>
            <td>1.00</td>
            <td>0.90</td>
            <td>-</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>程序语言使用经验 U<sub>12</sub></td>
            <td>1.41</td>
            <td>1.07</td>
            <td>1.00</td>
            <td>0.95</td>
            <td>-</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td rowspan="3">项目因素类</td>
            <td>现代程序设计技术 U<sub>13</sub></td>
            <td>1.24</td>
            <td>1.10</td>
            <td>1.00</td>
            <td>0.91</td>
            <td>0.82</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>软件工具的使用 U<sub>14</sub></td>
            <td>1.24</td>
            <td>1.10</td>
            <td>1.00</td>
            <td>0.91</td>
            <td>0.83</td>
            <td>-</td>
        </tr>
        <tr align="center">
            <td>开发进度限制 U<sub>15</sub></td>
            <td>1.23</td>
            <td>1.08</td>
            <td>1.00</td>
            <td>1.04</td>
            <td>1.10</td>
            <td>-</td>
        </tr>
    </tbody>
</table>
【例3.1】某软件企业中标了某嵌入型软件工程项目，预计 10k DSI 代码量，根据该软件的需求以及开发投入情况，用 COCOMO 求得该项目的综合影响要素 U 为 1.36，从该企业的信息数据库得知工时费用率 a = 9000 元/人·月，试对该软件的成本、工作量与工期做出估算。

<p>解：根据题意以及嵌入型软件的形式参数值可得：<br>$$<br>M_0 &#x3D; r·L^k &#x3D; 2.8 × 10^{1.2} &#x3D; 44.38 （人·月）<br>$$</p>
<p>$$<br>M_s &#x3D; U·M_0 &#x3D; 1.36 × 44.38 &#x3D; 60.4（人·月）<br>$$</p>
<p>$$<br>T_d &#x3D; h(M_s)^d &#x3D; 2.5 × 60.4^{0.32} &#x3D; 9.29（个月）<br>$$</p>
<p>$$<br>C_s &#x3D; a · M_s &#x3D; 9000 × 60.4 &#x3D; 54.36（万元）<br>$$</p>
<h3 id="3-2-3-类比法"><a href="#3-2-3-类比法" class="headerlink" title="3.2.3 类比法"></a>3.2.3 类比法</h3><p>软件企业开发软件通常有两种情况：①全新开发方式；②目标软件与以往开发的某款或者某些软件有许多相同或类似的结构，涉及的开发人员变化也较少，则可采用类比法来估算目标软件的成本。</p>
<p>假设某软件企业以往开发过一个类似的软件 S<sub>X</sub>，其软件规模为 L<sub>X</sub>；目标开发软件为 S<sub>Y</sub>,其软件规模为 L<sub>Y</sub>。由于目标开发软件的功能结构与原软件 S<sub>X</sub> 有很多类似之处，因此决定在 S<sub>X</sub> 的基础上改编成 S<sub>Y</sub>。</p>
<p>故引入调整系数 AC，主要通过设计修改 DMC、代码修改 CMC，以及集成修改 IMC 三部分构成。</p>
<p>调整系数 AC 可用下列公式表示：<br>$$<br>AC &#x3D; W_{1} · DMC + W_{2} · CMC + W_{3} · IMC<br>$$</p>
<p>式中 W<sub>j</sub>（j&#x3D;1，2，3）表示权重系数，其加权和必须等于 1。</p>
<p>B.W.Boehm 建议权重系数 W<sub>1</sub>，W<sub>2</sub>，W<sub>3</sub> 分别取值为 0.4、0.3 和 0.3。也就是下列公式。<br>$$<br>AC &#x3D; 0.4 · DMC + 0.3 · CMC + 0.3 · IMC<br>$$<br>由此可得 S<sub>Y</sub> 软件的开发规模 L<sub>Y</sub> 可以用下列公式表示。<br>$$<br>L_{Y} &#x3D; L_{X} · AC &#x3D; L_{X} · (0.4 · DMC + 0.3 · CMC + 0.3 · IMC)<br>$$</p>
<p>【例3.2】某软件公司曾开发过一种规模为 20k 代码量的软件 S<sub>X</sub>，现欲将其改编为嵌入型软件 S<sub>Y</sub>，经估算其设计、代码与集成修改的系数分别是 30%、40% 和 110%，工作量综合影响要素 U &#x3D; 1.2，工时费用率 a &#x3D; 8000 元&#x2F;人·月。试用类比法估算目标软件 S<sub>Y</sub> 的成本。</p>
<p>解：根据题意可得：<br>$$<br>AC &#x3D; W_{1} · DMC + W_{2} · CMC + W_{3} · IMC &#x3D; 0.4 × 0.3 + 0.3 × 0.4 + 0.3 × 1.10 &#x3D; 0.57<br>$$</p>
<p>$$<br>L_Y &#x3D; L_{X} · AC &#x3D; 20 kLOC × 0.57 &#x3D; 11.4 kLOC<br>$$</p>
<p>由题意可知，该软件属于嵌入型软件，查表可知相对应的形式参数值：<br>$$<br>M_s &#x3D; U·M_0 &#x3D; U · r · L^k &#x3D; 1.2 × 2.8 × 11.4^{1.20} &#x3D; 62.32（人·月）<br>$$</p>
<p>$$<br>C_s &#x3D; a·M_s &#x3D; 8000 × 62.32 &#x3D; 498560（元）<br>$$</p>
<h3 id="3-2-4-设备的磨损与折旧"><a href="#3-2-4-设备的磨损与折旧" class="headerlink" title="3.2.4 设备的磨损与折旧"></a>3.2.4 设备的磨损与折旧</h3><ol>
<li><p><strong>设备的磨损</strong></p>
<ol>
<li><p>设备的<strong>有形磨损</strong></p>
<p>有形磨损是指设备在生产使用或者闲置过程中，由于使用或者受自然环境的影响所产生的损耗。</p>
<p>设备的有形磨损根据导致其磨损的不同原因可分为：</p>
<ul>
<li>第 Ⅰ 类有形磨损</li>
<li>第 Ⅱ 类有形磨损</li>
</ul>
</li>
<li><p>设备的<strong>无形磨损</strong></p>
<p>无形磨损是指随着科技的进步等原因导致设备价值不断降低的现象。</p>
<p>设备的无形磨损根据导致其磨损的不同原因可分为：</p>
<ul>
<li>第 Ⅰ 类无形磨损</li>
<li>第 Ⅱ 类无形磨损</li>
</ul>
</li>
<li><p>设备的<strong>综合磨损</strong></p>
<p>综合磨损是指设备购置后既产生了<strong>有形磨损</strong>又产生了<strong>无形磨损</strong>。</p>
<p>假设设备发生有形磨损后，其剩余价值占原始价值的百分比可表示为 1-α<sub>p</sub>；而设备产生无形磨损后，其剩余价值占原始价值的百分比可表示为 1-α<sub>q</sub>，及设备的综合磨损的计算公式如下：<br>$$<br>α &#x3D; 1 - (1-α_p)(1-α_q)<br>$$<br>【例3.3】某 IT 企业原始购买价值为 23000 元的 A 电子设备在使用过程中发生磨损，需要修理，修理费用为 4000 元，若重置同类设备价值为 20000 元，若新旧设备生产率及单位产品消耗是相同的，试求该电子设备的综合磨损程度及剩余价值。</p>
<p>解：由题意可知， K<sub>0</sub> &#x3D; 23000（元），R &#x3D; 4000（元），K<sub>1</sub> &#x3D; 20000（元）。</p>
<p>A 电子设备的有形磨损程度为<br>$$<br>α_p &#x3D; \frac{R}{K_{1}} &#x3D; \frac{4000}{20000} &#x3D; 0.2<br>$$<br>A 电子设备的无形磨损程度为<br>$$<br>α_q &#x3D; 1 - \frac{K_{1}}{K_{0}} &#x3D; 1 - \frac{20000}{23000} &#x3D; 0.13<br>$$<br>A 电子设备的综合磨损程度为<br>$$<br>α &#x3D; 1 - (1-α_p)(1-α_q) &#x3D; 1-(1-0.2)(1-0.13) &#x3D; 0.304<br>$$<br>A 电子设备的剩余价值为<br>$$<br>K &#x3D; K_1 - R &#x3D; 20000 - 4000 &#x3D; 16000（元）<br>$$<br>故该电子设备的综合磨损程度是 30.4%，其剩余价值是 16000 元。</p>
</li>
</ol>
</li>
<li><p><strong>设备的折旧</strong></p>
<p>我国现行财会制度规定的固定资产折旧法主要有<strong>平均年限法</strong>和<strong>双倍余额递减法</strong>。</p>
</li>
</ol>
<h2 id="3-3-价值工程"><a href="#3-3-价值工程" class="headerlink" title="3.3 价值工程"></a>3.3 价值工程</h2><h3 id="3-3-1-价值工程的基本原理"><a href="#3-3-1-价值工程的基本原理" class="headerlink" title="3.3.1 价值工程的基本原理"></a>3.3.1 价值工程的基本原理</h3><p>价值工程设计的三个基本概念：<strong>价值（ Value ）</strong>、<strong>功能（ Function ）</strong>和<strong>全寿命周期成本（ Cost ）</strong>。</p>
<ol>
<li><p><strong>提高软件工程项目价值的途径</strong></p>
<ol>
<li>双向型</li>
<li>节约型</li>
<li>改进型</li>
<li>牺牲型</li>
<li>投资型</li>
</ol>
<p>上述提高价值的方法中，1、2 属于降低成本，3、5 属于提高功能，1 是对功能与成本同时进行改善，是最积极、最理想的提高价值的方法。</p>
</li>
<li><p><strong>价值工程的主要特征</strong></p>
<ol>
<li>价值工程以用户的功能需求为出发点；</li>
<li>价值工程以功能分析为核心，系统地研究功能和成本之间的关系；</li>
<li>价值工程是致力于提高价值的创造性活动；</li>
<li>价值工程是有计划、有组织地按照一定地工序来进行。</li>
</ol>
</li>
</ol>
<h3 id="3-3-2-价值工程的实施步骤与方法"><a href="#3-3-2-价值工程的实施步骤与方法" class="headerlink" title="3.3.2 价值工程的实施步骤与方法"></a>3.3.2 价值工程的实施步骤与方法</h3><ol>
<li>百分比法</li>
<li>ABC 分类法</li>
<li>价值系数法</li>
</ol>
<h3 id="3-3-3-功能分析与评价"><a href="#3-3-3-功能分析与评价" class="headerlink" title="3.3.3 功能分析与评价"></a>3.3.3 功能分析与评价</h3><p>功能分析主要包括<strong>功能定义</strong>与<strong>功能整理</strong>两方面的内容。</p>
<p>功能整理的步骤如下：</p>
<ol>
<li>分析软件产品的基本功能与辅助功能；</li>
<li>明确功能的上下位与并列关系；</li>
<li>排列功能系统图。</li>
</ol>
<h3 id="3-3-4-挣值管理"><a href="#3-3-4-挣值管理" class="headerlink" title="3.3.4 挣值管理"></a>3.3.4 挣值管理</h3><ol>
<li><strong>挣值分析的基本概念</strong><ol>
<li>计划价值</li>
<li>实际成本</li>
<li>挣值</li>
<li>完工预算</li>
</ol>
</li>
<li><strong>挣值分析的绩效指标</strong><ol>
<li>成本偏差</li>
<li>进度偏差</li>
<li>进度绩效指标</li>
<li>成本绩效指标</li>
</ol>
</li>
<li><strong>挣值分析的预测指标</strong><ol>
<li>完工尚需估算</li>
<li>完工估算</li>
<li>完工尚需绩效指标</li>
</ol>
</li>
</ol>
<h2 id="3-4-软件产品的定价与营销"><a href="#3-4-软件产品的定价与营销" class="headerlink" title="3.4 软件产品的定价与营销"></a>3.4 软件产品的定价与营销</h2><h3 id="3-4-1-软件产品的定价"><a href="#3-4-1-软件产品的定价" class="headerlink" title="3.4.1 软件产品的定价"></a>3.4.1 软件产品的定价</h3><p>软件企业的定价策略：</p>
<ol>
<li>捆绑定价策略</li>
<li>撇脂和渗透定价策略<ul>
<li>撇脂定价法</li>
<li>渗透定价法</li>
</ul>
</li>
<li>歧视定价策略</li>
<li>免费使用定价策略</li>
</ol>
<h3 id="3-4-2-软件产品的营销"><a href="#3-4-2-软件产品的营销" class="headerlink" title="3.4.2 软件产品的营销"></a>3.4.2 软件产品的营销</h3><p>软件产品的促销策略确定：</p>
<p>促销是促进营销的简称，是指采用人员或非人员的方式来帮助或说服客户购买某软件元产品／软件服务，或者让消费者对某个或者某些软件产品产生好感的一种活动。</p>
<p>促销策略主要包括<strong>直接促销</strong>和<strong>间接促销</strong>。直接促销是指人员上门推销软件产品的活动；间接促销是指采用各种媒体广告、营销推广与公共关系宣传等方式进行推销软件产品的活动。</p>
<p>软件作为一种特殊的无形产品，除了上述促销手段外，还有一些特殊的促销手段，如<strong>品牌促销</strong>、<strong>教育促销</strong>以及<strong>人员促销</strong>等。</p>
<ol>
<li><p>品牌促销</p>
<p>软件产品／软件服务是一种高技术产品，一般用户在购买软件产品前往往都会心存疑虑。一个良好的软件产品形象能大大消除用户的购买疑虑，让用户产生安全感和信任感。因此，软件企业要大力提高品牌知名度，让客户对软件企业产生信任感，放心购买其产品。软件企业可以通过树立品牌形象，引入企业形象识别系统以及发布产品广告、企业形象广告，建立企业网站、媒体宣传等多种手段来扩大企业的品牌知名度。</p>
</li>
<li><p>教育促销</p>
<p>软件的高科技特性会导致用户较难理解与掌握，软件企业需要利用各种场合来演示自己的产品，如通过软件博览会、展销会等，让目标用户与潜在用户了解该产品的主要功能。教育促销可通过向媒体发送免费的测试软件、认证培训、举办讲座等方式进行普及知识；利用展会进行产品展示等多种手段来扩大软件产品的宣传。</p>
</li>
<li><p>人员促销</p>
<p>人员促销应注重沟通能力以及人际关系。软件企业通过专业的服务人员与用户实现有效的沟通，为客户做好完备的前期咨询工作。这种方式针对性强，让客户觉得自己备受重视，无效劳动少，因此促销成功的概率会比较高。人员促销也有利于软件企业了解市场，能够给软件企业营销决策提供有效的建议与意见。人员促销需要注意以下问题：</p>
<ol>
<li>挑选专业技术能力强、个人素质高的促销人员；</li>
<li>软件企业要根据目标市场的特点、产品的特点等，对促销人员进行资源、促销区域、促销时间等进行合理分配；</li>
<li>软件企业要对促销人员实施有效的管理与激励，以确保促销目标的实现。</li>
</ol>
</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章 软件工程项目评价方法与经济效果评价</title>
    <url>/posts/a0090004.html</url>
    <content><![CDATA[<h2 id="4-1-软件工程项目评价与决策方法"><a href="#4-1-软件工程项目评价与决策方法" class="headerlink" title="4.1 软件工程项目评价与决策方法"></a>4.1 软件工程项目评价与决策方法</h2><h3 id="4-1-1-关联矩阵法"><a href="#4-1-1-关联矩阵法" class="headerlink" title="4.1.1 关联矩阵法"></a>4.1.1 关联矩阵法</h3><p>关联矩阵（ Relational Matrix Analysis，RMA ）法主要在确定好评价对象及评价指标后，通过二分法确定每个评价指标的权重 W<sub>j</sub>，并根据评价主体给定的评价指标的评价尺度，确定方案的综合评定价值量（ V<sub>ij</sub> ）。</p>
<h3 id="4-1-2-层次分析法"><a href="#4-1-2-层次分析法" class="headerlink" title="4.1.2 层次分析法"></a>4.1.2 层次分析法</h3><p>层次分析法的步骤如下：</p>
<ol>
<li>建立层次结构模型</li>
<li>构造判断比较矩阵</li>
<li>进行层次单排序</li>
<li>进行一致性检验</li>
</ol>
<h3 id="4-1-3-平均值法"><a href="#4-1-3-平均值法" class="headerlink" title="4.1.3 平均值法"></a>4.1.3 平均值法</h3><p>平均值法是指计算每个待评价方案 A<sub>k</sub> 在不同综合评价方法求解结果中的平均“优序”数，并依据每个待评价方案的平均优序数大小来决定该方案的排序位置的评价方法。、</p>
<p>【例4.4】设有 5 个待评方案，采用 4 种综合评价方法求解，其求解所得的排序结果如下表所示，试运用平均值法确定这 5 种方案的最终排序。</p>
<table>
<thead>
<tr>
<th align="center">方案</th>
<th align="center">M<sub>1</sub></th>
<th align="center">M<sub>2</sub></th>
<th align="center">M<sub>3</sub></th>
<th align="center">M<sub>4</sub></th>
</tr>
</thead>
<tbody><tr>
<td align="center">A<sub>1</sub></td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">A<sub>2</sub></td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">A<sub>3</sub></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">A<sub>4</sub></td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">1</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">A<sub>5</sub></td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>解：根据题意和表数据可得：<br>$$<br>\bar{d_1} &#x3D; \frac{1+3+2+3}{4} &#x3D; 2.25<br>$$</p>
<p>$$<br>\bar{d_2} &#x3D; \frac{3+1+3+5}{4} &#x3D; 3<br>$$</p>
<p>$$<br>\bar{d_3} &#x3D; \frac{2+2+4+2}{4} &#x3D; 2.5<br>$$</p>
<p>$$<br>\bar{d_4} &#x3D; \frac{4+5+1+4}{4} &#x3D; 3.5<br>$$</p>
<p>$$<br>\bar{d_5} &#x3D; \frac{5+4+5+1}{4} &#x3D; 3.75<br>$$</p>
<p>由于<br>$$<br>\bar{d_1}&lt;\bar{d_3}&lt;\bar{d_2}&lt;\bar{d_4}&lt;\bar{d_5}<br>$$<br>故有最终排序结果为<br>$$<br>A_1&gt;A_3&gt;A_2&gt;A_4&gt;A_5<br>$$</p>
<h2 id="4-2-软件工程项目的现金流量"><a href="#4-2-软件工程项目的现金流量" class="headerlink" title="4.2 软件工程项目的现金流量"></a>4.2 软件工程项目的现金流量</h2><ol>
<li>现金流入</li>
<li>现金流出</li>
<li>所得税前净现金流量</li>
<li>累计所得税前净现金流量</li>
<li>调整所得税</li>
<li>所得税后净现金流量</li>
<li>累计所得税后净现金流量</li>
</ol>
<h2 id="4-3-软件工程项目的经济效果评价"><a href="#4-3-软件工程项目的经济效果评价" class="headerlink" title="4.3 软件工程项目的经济效果评价"></a>4.3 软件工程项目的经济效果评价</h2><h3 id="4-3-1-独立方案项目评价"><a href="#4-3-1-独立方案项目评价" class="headerlink" title="4.3.1 独立方案项目评价"></a>4.3.1 独立方案项目评价</h3><p>所谓独立方案项目评价，是指<strong>对某一给定的软件工程项目投资方案从技术经济角度出发作出是否可行的判断或者评价。</strong></p>
<p>主要采用以下两种方法进行评价。</p>
<ol>
<li><p>净现值法</p>
<p>公式如下（无残值）：<br>$$<br>NPV &#x3D; \sum_{t&#x3D;0}^{N}\frac{B_t-C_t-K_t}{(1+i)^t}<br>$$<br>式中，NPV 表示软件项目工程的净现值；B<sub>t</sub> 表示软件工程项目在寿命期内第 t 期的收益；C<sub>t</sub> 表示软件工程项目在寿命期内第 t 期的成本或支出；K<sub>t</sub> 表示软件工程项目在寿命期内第 t 期的投资额；N 表示软件工程项目的使用年限；i 表示基准贴现率。</p>
<ul>
<li>若 NPV ＞ 0，则说明在基准贴现率 i 的水平下，该软件工程项目可盈利，从经济效果角度来看，该项目可投资。</li>
<li>若 NPV &lt;&#x3D; 0，则说明在基准贴现率 i 的水平下，该软件工程项目仅仅能够收支平衡甚至亏损，从经济效果角度来看，该项目投资不可行。</li>
</ul>
</li>
<li><p>内部收益率法</p>
</li>
</ol>
<h3 id="4-3-2-多方案项目评价"><a href="#4-3-2-多方案项目评价" class="headerlink" title="4.3.2 多方案项目评价"></a>4.3.2 多方案项目评价</h3><ol>
<li>净现值法</li>
<li>净年值法</li>
<li>研究期法</li>
<li>多方案组合排序法</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章 软件生产函数、效益分析及不确定性分析</title>
    <url>/posts/a0090005.html</url>
    <content><![CDATA[<h2 id="5-1-生产函数与软件生产函数"><a href="#5-1-生产函数与软件生产函数" class="headerlink" title="5.1 生产函数与软件生产函数"></a>5.1 生产函数与软件生产函数</h2><p>生产是指<strong>厂商对各种生产要素加以组合制成产品的过程</strong>。</p>
<p>所谓生产要素，就是生产过程中所使用的各种资源，主要包括劳动、资本、土地和企业家才能。</p>
<p>其中，劳动是指劳动者所提供的各种服务，主要有脑力劳动与体力劳动；资本是指生产过程中使用的资金；土地是指生产过程中使用的自然资源，如土地、森林、自然矿藏等；企业家才能是指企业家对整个生产过程的管理和组织工作，如经营能力、管理能力、组织能力以及创新能力等。</p>
<p>企业家根据市场预测，合理地配置生产要素来从事生产经营活动，以追求企业的利润最大化。</p>
<h3 id="5-1-1-生产函数和规模报酬"><a href="#5-1-1-生产函数和规模报酬" class="headerlink" title="5.1.1 生产函数和规模报酬"></a>5.1.1 生产函数和规模报酬</h3><ol>
<li><p><strong>生产函数的定义</strong></p>
<p>生产函数是指<strong>一定时期内生产要素的数量与某种组合同其所能产出的最大产量之间存在的函数关系</strong>。</p>
</li>
<li><p><strong>生产函数的特征</strong></p>
<p>生产函数通常满足以下三个特征：</p>
<ol>
<li>资本与劳动力的边际产出总是为正值，在劳动力（或者资本）投入量不变的情况下，资本（或者劳动力）的增加将引起产出的增加。</li>
<li>边际产量递减特性。当其他生产要素固定不变时，随着某一要素的投入量的增加，其边际产量将逐渐减少。</li>
<li>生产函数具有非负性，总产出必须是正值，且总产量是生产要素组合的结果，单一要素的投入是不能获得产出的。</li>
</ol>
</li>
<li><p><strong>规模报酬</strong></p>
<p>规模报酬又称为规模经济，主要研究所有要素都同比例增加时，产量发生变化的情况。</p>
<ul>
<li>当所有投入均增加一倍时，产出也相应地增加一倍，则称该生产技术是规模报酬不变；</li>
<li>当所有投入均增加一倍时，产出的增加是小于一倍的，则称该生产技术是规模报酬递减；</li>
<li>当所有投入均增加一倍时，产出的增加是大于一倍的，则称该生产技术是规模报酬递增。</li>
</ul>
<p>现实生产活动中，究竟出现哪一种情况，通常依赖于规模所达到的程度。在规模较小时，增加投入可以促进规模报酬递增，而当规模达到一定程度时，则会出现规模报酬递减的情况。</p>
</li>
</ol>
<h3 id="5-1-2-软件生产函数"><a href="#5-1-2-软件生产函数" class="headerlink" title="5.1.2 软件生产函数"></a>5.1.2 软件生产函数</h3><p>软件生产率是指<strong>软件开发的效率</strong>，是衡量软件开发水平的一个重要因素。</p>
<p>影响软件生产率的因素众多，主要有<strong>技术因素</strong>、<strong>管理因素</strong>以及<strong>文化因素</strong>。</p>
<p>提高软件生产率的主要举措有以下几方面：</p>
<ol>
<li><p><strong>技术方面</strong></p>
<ol>
<li>强调对企业研发人员个人职业能力的综合评估。为了提升个人对软件企业的贡献，有必要从专业、技能、经验、学历以及年龄等多方面进行考量。</li>
<li>软件技术领域最好根据研发人员所擅长的技术能力来划分不同的专业技术组。</li>
<li>培养研发人员对新技术的学习掌握，并创新应用。</li>
</ol>
</li>
<li><p><strong>管理方面</strong></p>
<ol>
<li>建立良好的人才激励机制，通过物质、精神奖励以及职务晋升制度提高研发人员的工作热情。</li>
<li>建立科学、合理的研发人员梯队制度，明确划分管理与技术领域人才。</li>
<li>依据软件企业所处的市场环境及企业自身发展的要求适时变革管理，用以应对不断变化的 IT 市场，进而增强软件企业的核心竞争力。</li>
</ol>
</li>
<li><p><strong>文化方面</strong></p>
<ol>
<li>建立良好的企业学习氛围。通过研发人员个人知识的学习、交流及共享来形成群体效应，提升整个企业的知识资源。</li>
<li>注重软件工程项目团队建设，加强团队合作精神，提高团队沟通能力。</li>
</ol>
</li>
</ol>
<h2 id="5-2-软件工程项目效益的特点与分类"><a href="#5-2-软件工程项目效益的特点与分类" class="headerlink" title="5.2 软件工程项目效益的特点与分类"></a>5.2 软件工程项目效益的特点与分类</h2><p>效益是指<strong>某项目实现后对项目主体方的基本目标的实现所产生的贡献</strong>。</p>
<p>如果该项目实现后对项目主体的基本目标有所贡献与促进，则称该项目具有正效益；如果该项目实现后，无助于项目主体的基本目标的实现甚至有阻碍作用，则称该项目具有负效益，或无效益。</p>
<h3 id="5-2-1-软件工程项目效益的特点"><a href="#5-2-1-软件工程项目效益的特点" class="headerlink" title="5.2.1 软件工程项目效益的特点"></a>5.2.1 软件工程项目效益的特点</h3><p>软件工程项目效益的特点有：</p>
<ol>
<li>软件工程项目的效益主要依赖于项目主体及其所追求的目标。项目主体如果是国家或者政府，其基本目标大多是社会效益（如出入境自助系统，智能交通系统等）；项目主体如果是一个企业，则其基本目标是实现利润的最大化。</li>
<li>软件工程项目的效益主要依赖于其基本目标提出时的历史时代背景。不同历史时代的同一项目主体的目标也会不同，如我国企业信息系统的追求目标从20世纪80年代初的为生产管理服务，到90年代初的为经营管理服务，再到21世纪初的为供应链管理服务，发展到现在的为大数据以及区块链的管理服务。由于项目主体对信息系统的基本目标随着时代变化，所以企业对效益的认识也随之不断地变化。</li>
<li>软件工程项目的投资主体和受益主体有两种形式，一种是二者相结合的，另一种是两者相分离的。</li>
</ol>
<h3 id="5-2-2-软件工程项目效益的分类"><a href="#5-2-2-软件工程项目效益的分类" class="headerlink" title="5.2.2 软件工程项目效益的分类"></a>5.2.2 软件工程项目效益的分类</h3><p>软件工程项目主体所提出的基本目标通常涉及经济、社会、科学技术、国防与军事，故软件工程项目的效益一般分为经济效益、社会效益、科学技术效益以及军事作战效益。</p>
<p>根据项目实现后对项目主体基本目标带来的贡献特征，又可将效益分为以下几种：</p>
<ol>
<li><strong>直接效益和间接效益。</strong>直接效益是指项目实施后对基本目标直接作出的贡献，如企业营销决策支持系统的实施将提高企业的销售收人和利润等。间接效益是指由目标项目实施后所引发的其他项目或企业带来的效益，如某软件企业承接了一个高校数字化建设项目，虽然该项目利润几乎为零，但为该企业今后进入教育行业开拓了新的市场，带来了未来类似的项目机会。</li>
<li><strong>内部效益与外部效益。</strong>项目内部效益是指项目投资经营主体获得的效益，其成本是由项目投资经营主体承担的，如城市交通信息系统项目，项目投资与运作的成本由政府承担。项目外部效益是指项目外的效益，外部效益的受益者不需要付出任何代价，如通行者经过免费大桥是大桥项目的外部效益。</li>
<li><strong>有形效益与无形效益。</strong>有形效益通常具有实物形态，容易用货币进行计度量，如水电站的发电量、收费公路的收费收入等。无形效益难以用货币进行度量，又难以用其他计量单位度量，且缺乏物质形态的效果，如国防项目提高国家威望、建筑物的美学价值等，都是难以用货币或其他计量单位度量的。</li>
</ol>
<h2 id="5-3-软件工程项目的经济效益与社会效益分析"><a href="#5-3-软件工程项目的经济效益与社会效益分析" class="headerlink" title="5.3 软件工程项目的经济效益与社会效益分析"></a>5.3 软件工程项目的经济效益与社会效益分析</h2><h3 id="5-3-1-软件工程项目的经济效益分析"><a href="#5-3-1-软件工程项目的经济效益分析" class="headerlink" title="5.3.1 软件工程项目的经济效益分析"></a>5.3.1 软件工程项目的经济效益分析</h3><p>不同的项目主体承担着不同的管理职能，且不同的项目主体（各企业）生产不同的产品，因此要给出一个统一的效益评价指标体系与通用的效益计算方法是比较困难的。</p>
<p>以下是 ERP 系统直接经济效益的计算方法：</p>
<ol>
<li>系统运行前后对比法</li>
<li>经验参数估计法</li>
</ol>
<h3 id="5-3-2-软件工程项目的社会效益分析"><a href="#5-3-2-软件工程项目的社会效益分析" class="headerlink" title="5.3.2 软件工程项目的社会效益分析"></a>5.3.2 软件工程项目的社会效益分析</h3><ol>
<li><p><strong>软件工程项目的分类</strong></p>
<p>软件工程项目从系统目标来看主要分为以下三类：</p>
<ol>
<li>软件目标是系统经济性的软件工程项目；</li>
<li>软件目标是系统社会性的软件工程项目；</li>
<li>系统目标是系统军事作战性的软件工程目标。</li>
</ol>
<p>根据满足社会性需要的不同，公益性软件大致可以分为以下类型：</p>
<ol>
<li>生产与生活服务工程，如供水系统、供电系统、供气系统、通信系统、邮政系统、交通运输系统等；</li>
<li>社会安全工程，如治安系统工程、城市消防系统等；</li>
<li>环境保护与灾害防治工程，如污染治理、防洪、水资源治理工程、野生资源保护工程、应急联动系统项目等；</li>
<li>科教与社会福利工程，如科研系统、学校信息系统、博物馆管理系统、医疗信息系统、游乐场信息系统等。</li>
</ol>
</li>
<li><p><strong>软件工程项目社会效益评价的特征</strong></p>
<p>软件工程项目的社会效益评价的主要特征有：</p>
<ol>
<li>由于其定量分析比较困难，系统评价以定性评价为主。</li>
<li>社会评价无通用方法。不同的软件工程项目，涉及众多行业与部门，其社会评价涉及的内容有较大不同，从而所采用的评价方法差异也较大。</li>
<li>对社会的贡献主要以间接效益、无形效果与外部效果为主。因为无形效果难以用货币进行度量，所以常用的方法为类比法和公众调查法。</li>
</ol>
<p>公益性软件系统通常需要进行社会效益分析，故人们常使用效益一成本分析法。</p>
</li>
</ol>
<h2 id="5-4-软件工程项目的不确定性分析"><a href="#5-4-软件工程项目的不确定性分析" class="headerlink" title="5.4 软件工程项目的不确定性分析"></a>5.4 软件工程项目的不确定性分析</h2><h3 id="5-4-1-项目不确定性因素产生的原因"><a href="#5-4-1-项目不确定性因素产生的原因" class="headerlink" title="5.4.1 项目不确定性因素产生的原因"></a>5.4.1 项目不确定性因素产生的原因</h3><p>项目不确定性因素产生的原因可以归纳为以下几点：</p>
<ol>
<li>统计误差。</li>
<li>宏观经济的影响。</li>
<li>技术更新的影响。</li>
<li>微观市场的影响。</li>
<li>其他外部因素的影响。</li>
</ol>
<h3 id="5-4-2-项目不确定性分析的作用"><a href="#5-4-2-项目不确定性分析的作用" class="headerlink" title="5.4.2 项目不确定性分析的作用"></a>5.4.2 项目不确定性分析的作用</h3><p>不确定性分析是软件工程项目经济评价中的一个重要内容。</p>
<p>因为项目前评价通常是以些确定的数据为基础的，如项目总投资、项目周期、年销售收人、年经营成本、年利率等指标值往往是已知的、确定的，即使对某个指标值所作的估算也认为是可靠且有效的。</p>
<p>实际上，由于上述不确定性因素的存在，这些指标值与实际值之间往往存在较大差异，这样就导致项目评价的结果产生了影响。</p>
<p>如果不对此进行分析，就可能会引起投资决策的失误。例如某软件工程项目的基准收益率 i 为 9%，根据项目基础数据求出的项目内部收益率为 10%，由于内部收益率大于基准收益率，根据方案的评价准则必定认为该项目是可行的。</p>
<p>但如果凭此就做出投资决策是有失周全的，因为还没有考虑到不确定性因素问题。</p>
<p>如果在该项目实施过程中存在通货膨胀，且通货膨胀大于 2%，则项目的风险就会较大。因此，为了有效减少不确定性因素对软件工程项目经济效果的影响，提高项目的风险防范能力，进而提高项目投资决策的科学性和可靠性，除对项目进行确定性分析以外，还很有必要对软件工程项目进行不确定性分析。</p>
<h3 id="5-4-3-项目不确定性分析的方法与步骤"><a href="#5-4-3-项目不确定性分析的方法与步骤" class="headerlink" title="5.4.3 项目不确定性分析的方法与步骤"></a>5.4.3 项目不确定性分析的方法与步骤</h3><ol>
<li><p><strong>项目不确定性分析的步骤</strong></p>
<ol>
<li><strong>鉴别不确定性因素。</strong>尽管软件工程项目在运行中所涉及的因素都具有不确定性，但在不同条件下的不确定性程度是不同的，故应找出不确定性程度较大的因素来进行分析。</li>
<li><strong>界定不确定性因素的性质。</strong>不确定性包括不可测定的不确定性与可测定的风险。对于不可测定的不确定性因素，应界定其变化的幅度与范围，确定其边界值；对可测定的风险因素应确定其概率分布状况。</li>
<li><strong>选择不确定性分析的方法。</strong>根据不确定性因素的性质，选择不确定性分析的方法。盈亏平衡分析与敏感性分析，适用于不可测定的不确定性分析，而概率分析适用于可测定的风险分析。</li>
<li><strong>明确不确定性分析的结果。</strong>根据分析的需要与依据的指标不同，不确定性分析的结果可分为平衡点确定、不同区间的方案选择、不同方案的比较选择、敏感度与敏感性因素的界定、风险预测等。</li>
</ol>
</li>
<li><p><strong>项目不确定性分析的方法</strong></p>
<p>常用的不确定性分析方法有<strong>盈亏平衡分析</strong>、<strong>敏感性分析</strong>、<strong>概率分析</strong>等。</p>
<p>在具体应用时，应综合考虑项目的类型、特点，决策者的要求，相应的人力、物力和财力，以及软件工程项目对国民经济的影响程度等条件后再来选择。</p>
<p>盈亏平衡分析只适用于项目的财务评价，而敏感性分析与概率分析则可以同时用于财务评价以及国民经济评价。</p>
<p>概率分析法是在选定不确定性因素的基础上，通过估计其发生变动的范围，然后根据已有资料或者经验等情况，估计出变化值出现的概率，并根据这些概率的大小，分析测算事件变动给项目经济效益带来的结果与所获结果稳定性的分析方法。</p>
<ol>
<li><p><strong>概率分析的步骤</strong></p>
<p>概率分析的步骤通常有以下六步：</p>
<ol>
<li>选定软件工程项目的效益指标（如内部收益率、净现值等）作为分析对象。</li>
<li>选定需要进行概率分析的不确定性因素，如软件产品的价格、投资额等。</li>
<li>估计出每个不确定性因素的变化范围以及可能出现的概率。单因素概率分析是设定一个因素变化，其他因素保持不变，即主要对一个自变量进行概率分析。多因素分析是设定多个因素同时变化，对多个自变量进行概率分析。</li>
<li>计算在不确定性因素变量的影响下投资经济效益的期望值。</li>
<li>计算出表明期望值稳定性的标准偏差。</li>
<li>综合考虑期望值与标准偏差，说明在该不确定性因素的影响下，软件工程项目的经济效益指标的期望值以及获得的可能性。</li>
</ol>
</li>
<li><p><strong>期望值</strong></p>
<p>期望值又称为数学期望，是随机事件的各种变量和相应概率的加权平均值。不确定性因素可能发生的变化值是随机变量，其出现的可能性大小为随机变量的概率。一系列随机变量所发生的概率排列称为概率分布，一个事件发生的全部概率分布的总和等于1，期望值就代表了不确定性因素在实际中最可能出现的数值。</p>
</li>
</ol>
</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章 软件工程项目进度计划的制订</title>
    <url>/posts/a0090006.html</url>
    <content><![CDATA[<h2 id="6-1-进度的基本概念"><a href="#6-1-进度的基本概念" class="headerlink" title="6.1 进度的基本概念"></a>6.1 进度的基本概念</h2><p>进度是指工作等进行的速度或进展的程度。对软件工程项目进行进度管理是为了确保项目根据需求能按期完成。</p>
<h3 id="6-1-1-软件工程项目的工作分解结构"><a href="#6-1-1-软件工程项目的工作分解结构" class="headerlink" title="6.1.1 软件工程项目的工作分解结构"></a>6.1.1 软件工程项目的工作分解结构</h3><p>工作分解结构（ Work Breakdown Structure，WBS ）以可交付成果为导向，把项目工作（或活动）分解为较小的、易于管理和控制的单元。</p>
<p>WBS 主要是对实现目标以及可交付成果进行的所有工作范围的层级分解。</p>
<p>软件工程项目管理人员在创建 WBS 时应注意下列四个要点：</p>
<ol>
<li>项目的某项工作应且只在 WBS 中的一个地方出现。</li>
<li>WBS 种某项工作的内容应是其下一层及所有 WBS 项的总和。</li>
<li>WBS 必须与项目实际工作中的执行方式一样。</li>
<li>同一层次的 WBS 应为相同性质，每个 WBS 工作单元都要有负责人。</li>
</ol>
<p>WBS 的创建步骤如下：</p>
<ol>
<li>识别可交付成果及相关工作。</li>
<li>确定 WBS 的分解方式和编排结构。</li>
<li>创建 WBS。</li>
<li>验证 WBS 的合理性及正确性。</li>
<li>建立 WBS 编码系统。</li>
</ol>
<h3 id="6-1-2-软件工程项目的进度网络计划图"><a href="#6-1-2-软件工程项目的进度网络计划图" class="headerlink" title="6.1.2 软件工程项目的进度网络计划图"></a>6.1.2 软件工程项目的进度网络计划图</h3><p>先行工作 A 与后继工作 B 主要包括以下四种依赖关系：</p>
<ol>
<li><p>完成对开始</p>
</li>
<li><p>开始对开始</p>
</li>
<li><p>完成对完成</p>
</li>
<li><p>开始对完成</p>
</li>
<li><p><strong>双代号网络计划图的绘制规则</strong></p>
<ol>
<li>网络计划图应正确表达各项目工作之间已定的逻辑关系。</li>
<li>不得出现回路。</li>
<li>不得出现双箭头或者不带箭头的活动。</li>
<li>不得出现没有箭头节点或没有箭尾节点的箭线。</li>
<li>当起点节点有多条向外箭线或终点节点有多条内向箭线时，对起点节点和终点节点可使用母线法绘图。</li>
<li>绘制网络计划图的箭线时不宜有交叉，当交叉不可避免时，可用过桥法、断线法或指向法。</li>
<li>网络计划图种必须只有一个起点节点（编号为 ① ）；在不分期完成任务的网络计划图中，必须只有一个终点节点；其他所有节点均为中间节点。</li>
<li>不允许出现相同编号的工作（任务&#x2F;活动）或者节点。</li>
<li>绘制的箭线应主要以水平线为主，竖线和斜线为辅，不应画成曲线。</li>
<li>绘制网络计划图时应该条理清晰、布局合理，尽量把关键路线安排在中心醒目的位置。</li>
</ol>
</li>
<li><p><strong>项目工作时长的算法</strong></p>
<ol>
<li><p>三点估算法</p>
<p>用 t<sub>e</sub> 表示工作时长，t<sub>0</sub> 表示最乐观完成时间，t<sub>p</sub> 表示最悲观完成时间，t<sub>m</sub> 表示最可能完成时间，则<br>$$<br>t_e &#x3D; \frac{t_0+4t_m+t_p}{6}<br>$$</p>
</li>
<li><p>专家估算法</p>
<p>公式如下：<br>$$<br>t_e &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n}t_i<br>$$</p>
</li>
</ol>
</li>
</ol>
<h2 id="6-2-软件工程项目进度分析"><a href="#6-2-软件工程项目进度分析" class="headerlink" title="6.2 软件工程项目进度分析"></a>6.2 软件工程项目进度分析</h2><h3 id="6-2-1-关键工作及关键线路"><a href="#6-2-1-关键工作及关键线路" class="headerlink" title="6.2.1 关键工作及关键线路"></a>6.2.1 关键工作及关键线路</h3><p>关键工作及关键线路的确定一般需要符合如下规定：</p>
<ol>
<li>总时差最少的项目工作应确定为关键工作。</li>
<li>在网络计划图中，关键线路一般用粗线、双线或者彩色线标注出来。</li>
<li>一般情况下，一个网络计划图中至少会有一条关键线路，最多只能有有线条关键线路。</li>
</ol>
<h3 id="6-2-2-关键线路求解"><a href="#6-2-2-关键线路求解" class="headerlink" title="6.2.2 关键线路求解"></a>6.2.2 关键线路求解</h3><ol>
<li><strong>通过时间参数确定关键线路</strong></li>
<li><strong>通过标号法确定关键线路</strong></li>
</ol>
<h2 id="6-3-网络计划优化"><a href="#6-3-网络计划优化" class="headerlink" title="6.3 网络计划优化"></a>6.3 网络计划优化</h2><h3 id="6-3-1-工期优化"><a href="#6-3-1-工期优化" class="headerlink" title="6.3.1 工期优化"></a>6.3.1 工期优化</h3><p>如果软件工程项目的计算工期 T<sub>p</sub> ，大于要求工期 T<sub>r</sub>，则可以通过压缩关键工作的工作时长来优化工期。</p>
<p>软件工程项目工期优化的计算应按照以下步骤进行：</p>
<ol>
<li>计算并找出初始网络计划的计算工期 T<sub>p</sub>、关键工作和关键线路。、</li>
<li>按要求工期 T<sub>r</sub> 计算应缩短的总工作时长。</li>
<li>确定软件工程项目中各个关键工作能缩短的工作时长。</li>
<li>选择缩短工作时长的关键工作。</li>
<li>当重新计算的工期仍然超过项目要求的工期时，则需重复步骤 1~4，直至满足项目的要求或不能再压缩了为止。</li>
<li>当项目的所有关键工作的工作时长都已达到其能缩短的极限，而计算工期 T<sub>p</sub>，仍然不能满足项目的工期要求时，应对原软件工程项目计划的技术方案、组织方案进行调整，或者对项目要求工期 T<sub>r</sub>，进行重新审定。</li>
</ol>
<h3 id="6-3-2-资源优化"><a href="#6-3-2-资源优化" class="headerlink" title="6.3.2 资源优化"></a>6.3.2 资源优化</h3><p>网络计划主要有“<strong>资源有限，工期最短</strong>”和“<strong>工期固定，资源均衡</strong>”两种资源优化方式。</p>
<p>软件工程项目的网络计划资源优化主要使用“<strong>工期固定，资源均衡</strong>”的优化方式。</p>
<p>“工期固定，资源均衡”的优化是在保持项目工期不变的情况下，使资源分布尽量均衡，即在资源需用量的动态曲线上，尽可能不出现短时期的高峰和低谷，促使每个时段的资源需用量接近于平均值。</p>
<p>可使用“<strong>削高峰法</strong>”来进行“工期固定，资源均衡”的优化。</p>
<h3 id="6-3-3-工期—费用优化"><a href="#6-3-3-工期—费用优化" class="headerlink" title="6.3.3 工期—费用优化"></a>6.3.3 工期—费用优化</h3><p>工期—费用优化是<strong>通过对不同工期时的软件工程项目总费用的比较分析，从而寻求出项目总费用最低时的最优工期。</strong></p>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章 软件工程项目的团队建设、风险管理及质量管理</title>
    <url>/posts/a0090007.html</url>
    <content><![CDATA[<h2 id="7-1-软件工程项目的团队建设"><a href="#7-1-软件工程项目的团队建设" class="headerlink" title="7.1 软件工程项目的团队建设"></a>7.1 软件工程项目的团队建设</h2><h3 id="7-1-1-软件工程项目团队的特点"><a href="#7-1-1-软件工程项目团队的特点" class="headerlink" title="7.1.1 软件工程项目团队的特点"></a>7.1.1 软件工程项目团队的特点</h3><p>软件工程项目团队的特点主要有：</p>
<ol>
<li>软件工程项目团队的目的性。</li>
<li>软件工程项目团队的临时性。</li>
<li>软件工程项目团队的合作性。</li>
<li>软件工程项目团队的凝聚力。</li>
</ol>
<h3 id="7-1-2-软件工程项目团队的作用"><a href="#7-1-2-软件工程项目团队的作用" class="headerlink" title="7.1.2 软件工程项目团队的作用"></a>7.1.2 软件工程项目团队的作用</h3><p>软件工程项目通常以团队的形式来完成任务，其团队的作用主要有：</p>
<ol>
<li>能够更有效地实现目标。</li>
<li>能够满足团队成员的心理需求。</li>
<li>能够使个人得到较快的进步。</li>
<li>能够提高决策质量。</li>
</ol>
<h2 id="7-2-软件工程项目的风险管理"><a href="#7-2-软件工程项目的风险管理" class="headerlink" title="7.2 软件工程项目的风险管理"></a>7.2 软件工程项目的风险管理</h2><h3 id="7-2-1-软件工程项目风险概述"><a href="#7-2-1-软件工程项目风险概述" class="headerlink" title="7.2.1 软件工程项目风险概述"></a>7.2.1 软件工程项目风险概述</h3><ol>
<li><strong>软件工程项目风险的特点：</strong><ol>
<li>风险存在的普遍性与客观性。</li>
<li>风险的偶然性与必然性。</li>
<li>风险的不确定性。</li>
<li>风险的多样性与层次性。</li>
</ol>
</li>
<li><strong>软件工程项目风险的分类：</strong><ol>
<li>技术风险</li>
<li>进度风险</li>
<li>费用风险</li>
<li>管理风险</li>
<li>已知风险</li>
<li>不可预测风险</li>
<li>可预测风险</li>
<li>社会环境风险</li>
<li>商业风险</li>
</ol>
</li>
<li><strong>风险管理的步骤：</strong><ol>
<li>风险识别</li>
<li>风险分析</li>
<li>风险规划</li>
<li>风险控制</li>
</ol>
</li>
</ol>
<h3 id="7-2-2-软件工程项目的风险识别"><a href="#7-2-2-软件工程项目的风险识别" class="headerlink" title="7.2.2 软件工程项目的风险识别"></a>7.2.2 软件工程项目的风险识别</h3><ol>
<li><strong>软件工程项目风险识别的内容：</strong><ol>
<li>识别并确定软件工程项目有哪些潜在的危险。</li>
<li>识别引起这些项目风险的主要影响因素有哪些。</li>
<li>识别软件工程项目风险可能引起的后果。</li>
</ol>
</li>
<li><strong>软件工程项目风险识别的方法：</strong><ol>
<li>头脑风暴法</li>
<li>德尔非法</li>
<li>访谈法</li>
<li>情景分析法</li>
<li>风险条目检查法</li>
</ol>
</li>
</ol>
<h3 id="7-2-3-软件工程项目的风险响应规划"><a href="#7-2-3-软件工程项目的风险响应规划" class="headerlink" title="7.2.3 软件工程项目的风险响应规划"></a>7.2.3 软件工程项目的风险响应规划</h3><ol>
<li><strong>应对负面风险的策略</strong><ol>
<li>风险规避策略</li>
<li>风险承担策略</li>
<li>风险转移策略</li>
<li>风险缓解策略</li>
</ol>
</li>
<li><strong>应对正面风险的策略</strong><ol>
<li>风险开发策略</li>
<li>风险共享策略</li>
<li>风险增强策略</li>
<li>风险承担策略</li>
</ol>
</li>
</ol>
<h2 id="7-3-软件工程项目的质量管理"><a href="#7-3-软件工程项目的质量管理" class="headerlink" title="7.3 软件工程项目的质量管理"></a>7.3 软件工程项目的质量管理</h2><h3 id="7-3-1-影响软件质量的因素"><a href="#7-3-1-影响软件质量的因素" class="headerlink" title="7.3.1 影响软件质量的因素"></a>7.3.1 影响软件质量的因素</h3><ol>
<li>人的因素（ M ）</li>
<li>过程因素（ P ）</li>
<li>技术因素（ T ）</li>
</ol>
<h3 id="7-3-2-软件质量模型"><a href="#7-3-2-软件质量模型" class="headerlink" title="7.3.2 软件质量模型"></a>7.3.2 软件质量模型</h3><ol>
<li>McCall 模型</li>
<li>“FURPS”及“FURPS+”模型</li>
<li>Boehm 模型</li>
<li>ISO&#x2F;IEC 9126 模型</li>
</ol>
<h3 id="7-3-3-软件质量保证的内容"><a href="#7-3-3-软件质量保证的内容" class="headerlink" title="7.3.3 软件质量保证的内容"></a>7.3.3 软件质量保证的内容</h3><p>软件质量保证（ Software Quality Assurance，SQA ）的主要工作内容有：</p>
<ol>
<li>与软件质量保证计划直接相关的各项工作。</li>
<li>参与软件工程项目的阶段性评审及审计。</li>
<li>对软件工程项目常规活动与规程的符合性进行检查。</li>
<li>对项目的配置管理工作的检查及审计。</li>
<li>跟踪所发现问题的解决情况。</li>
<li>在软件质量保证过程中收集新方法，提供过程改进的相关依据。</li>
<li>生成软件质量审计报告。</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础</title>
    <url>/posts/c0010000.html</url>
    <content><![CDATA[<h2 id="Java-入门：基本语法篇"><a href="#Java-入门：基本语法篇" class="headerlink" title="Java 入门：基本语法篇"></a>Java 入门：基本语法篇</h2><h3 id="第1章-Java-语言概述"><a href="#第1章-Java-语言概述" class="headerlink" title="第1章 Java 语言概述"></a><a href="https://georgedi.top/posts/c0010001.html">第1章 Java 语言概述</a></h3><h3 id="第2章-变量与运算符"><a href="#第2章-变量与运算符" class="headerlink" title="第2章 变量与运算符"></a><a href="https://georgedi.top/posts/c0010002.html">第2章 变量与运算符</a></h3><h3 id="第3章-流程控制语句"><a href="#第3章-流程控制语句" class="headerlink" title="第3章 流程控制语句"></a><a href="https://georgedi.top/posts/c0010003.html">第3章 流程控制语句</a></h3><h3 id="第4章-数组"><a href="#第4章-数组" class="headerlink" title="第4章 数组"></a><a href="https://georgedi.top/posts/c0010004.html">第4章 数组</a></h3><h2 id="Java-进阶：面向对象篇"><a href="#Java-进阶：面向对象篇" class="headerlink" title="Java 进阶：面向对象篇"></a>Java 进阶：面向对象篇</h2><h3 id="第5章-面向对象编程基础"><a href="#第5章-面向对象编程基础" class="headerlink" title="第5章 面向对象编程基础"></a><a href="https://georgedi.top/posts/c0010005.html">第5章 面向对象编程基础</a></h3><h3 id="第6章-面向对象编程进阶"><a href="#第6章-面向对象编程进阶" class="headerlink" title="第6章 面向对象编程进阶"></a><a href="https://georgedi.top/posts/c0010006.html">第6章 面向对象编程进阶</a></h3><h3 id="第7章-面向对象编程高级"><a href="#第7章-面向对象编程高级" class="headerlink" title="第7章 面向对象编程高级"></a><a href="https://georgedi.top/posts/c0010007.html">第7章 面向对象编程高级</a></h3><h2 id="Java-高级：高级应用篇"><a href="#Java-高级：高级应用篇" class="headerlink" title="Java 高级：高级应用篇"></a>Java 高级：高级应用篇</h2><h3 id="第8章-异常处理"><a href="#第8章-异常处理" class="headerlink" title="第8章 异常处理"></a><a href="https://georgedi.top/posts/c0010008.html">第8章 异常处理</a></h3><h3 id="第9章-多线程"><a href="#第9章-多线程" class="headerlink" title="第9章 多线程"></a><a href="https://georgedi.top/posts/c0010009.html">第9章 多线程</a></h3><h3 id="第10章-常用类"><a href="#第10章-常用类" class="headerlink" title="第10章 常用类"></a><a href="https://georgedi.top/posts/c0010010.html">第10章 常用类</a></h3><h3 id="第11章-基础-API"><a href="#第11章-基础-API" class="headerlink" title="第11章 基础 API"></a><a href="https://georgedi.top/posts/c0010011.html">第11章 基础 API</a></h3><h3 id="第12章-集合框架"><a href="#第12章-集合框架" class="headerlink" title="第12章 集合框架"></a><a href="https://georgedi.top/posts/c0010012.html">第12章 集合框架</a></h3><h3 id="第13章-泛型"><a href="#第13章-泛型" class="headerlink" title="第13章 泛型"></a><a href="https://georgedi.top/posts/c0010013.html">第13章 泛型</a></h3><h3 id="第14章-数据结构与集合源码"><a href="#第14章-数据结构与集合源码" class="headerlink" title="第14章 数据结构与集合源码"></a><a href="https://georgedi.top/posts/c0010014.html">第14章 数据结构与集合源码</a></h3><h3 id="第15章-File-类与-IO-流"><a href="#第15章-File-类与-IO-流" class="headerlink" title="第15章 File 类与 IO 流"></a><a href="https://georgedi.top/posts/c0010015.html">第15章 File 类与 IO 流</a></h3><h3 id="第16章-网络编程"><a href="#第16章-网络编程" class="headerlink" title="第16章 网络编程"></a><a href="https://georgedi.top/posts/c0010016.html">第16章 网络编程</a></h3><h3 id="第17章-反射机制"><a href="#第17章-反射机制" class="headerlink" title="第17章 反射机制"></a><a href="https://georgedi.top/posts/c0010017.html">第17章 反射机制</a></h3><h2 id="Java-番外篇"><a href="#Java-番外篇" class="headerlink" title="Java 番外篇"></a>Java 番外篇</h2><h3 id="Java番外一：JDK-的安装与环境配置"><a href="#Java番外一：JDK-的安装与环境配置" class="headerlink" title="Java番外一：JDK 的安装与环境配置"></a><a href="https://georgedi.top/posts/c0010018.html">Java番外一：JDK 的安装与环境配置</a></h3><h3 id="Java番外二：JDK-8-17-新特性"><a href="#Java番外二：JDK-8-17-新特性" class="headerlink" title="Java番外二：JDK 8-17 新特性"></a><a href="https://georgedi.top/posts/c0010019.html">Java番外二：JDK 8-17 新特性</a></h3>]]></content>
      <categories>
        <category>后端技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章 软件测试</title>
    <url>/posts/a0090008.html</url>
    <content><![CDATA[<h2 id="8-1-软件测试的模型"><a href="#8-1-软件测试的模型" class="headerlink" title="8.1 软件测试的模型"></a>8.1 软件测试的模型</h2><h3 id="8-1-1-软件测试-V-模型"><a href="#8-1-1-软件测试-V-模型" class="headerlink" title="8.1.1 软件测试 V 模型"></a>8.1.1 软件测试 V 模型</h3><h3 id="8-1-2-软件测试-W-模型"><a href="#8-1-2-软件测试-W-模型" class="headerlink" title="8.1.2 软件测试 W 模型"></a>8.1.2 软件测试 W 模型</h3><h3 id="8-1-3-软件测试-H-模型"><a href="#8-1-3-软件测试-H-模型" class="headerlink" title="8.1.3 软件测试 H 模型"></a>8.1.3 软件测试 H 模型</h3><h3 id="8-1-4-软件测试-X-模型"><a href="#8-1-4-软件测试-X-模型" class="headerlink" title="8.1.4 软件测试 X 模型"></a>8.1.4 软件测试 X 模型</h3><h3 id="8-1-5-前置测试模型"><a href="#8-1-5-前置测试模型" class="headerlink" title="8.1.5 前置测试模型"></a>8.1.5 前置测试模型</h3><h2 id="8-2-软件测试的类型"><a href="#8-2-软件测试的类型" class="headerlink" title="8.2 软件测试的类型"></a>8.2 软件测试的类型</h2><h3 id="8-2-1-按开发阶段划分"><a href="#8-2-1-按开发阶段划分" class="headerlink" title="8.2.1 按开发阶段划分"></a>8.2.1 按开发阶段划分</h3><p>按照开发阶段划分，软件测试可分为<strong>单元测试</strong>、<strong>集成测试</strong>、<strong>系统测试</strong>和<strong>验收测试</strong>。</p>
<h3 id="8-2-2-按测试实施组织划分"><a href="#8-2-2-按测试实施组织划分" class="headerlink" title="8.2.2 按测试实施组织划分"></a>8.2.2 按测试实施组织划分</h3><p>按照测试实施组织划分，软件测试可分为<strong>开发方测试</strong>、<strong>用户方测试</strong>与<strong>第三方测试</strong>。</p>
<h3 id="8-2-3-按测试技术划分"><a href="#8-2-3-按测试技术划分" class="headerlink" title="8.2.3 按测试技术划分"></a>8.2.3 按测试技术划分</h3><p>按照测试技术划分，软件测试可分为<strong>黑盒测试</strong>、<strong>白盒测试</strong>与<strong>灰盒测试</strong>。</p>
<h3 id="8-2-4-按测试执行方式划分"><a href="#8-2-4-按测试执行方式划分" class="headerlink" title="8.2.4 按测试执行方式划分"></a>8.2.4 按测试执行方式划分</h3><p>按照测试执行的方式划分，软件测试可分为<strong>静态测试</strong>和<strong>动态测试</strong>。</p>
<h3 id="8-2-5-按测试对象类型划分"><a href="#8-2-5-按测试对象类型划分" class="headerlink" title="8.2.5 按测试对象类型划分"></a>8.2.5 按测试对象类型划分</h3><p>按照测试的对象类型划分，软件测试可分为<strong>功能测试</strong>、<strong>界面测试</strong>、<strong>流程测试</strong>、<strong>接口测试</strong>、<strong>安装测试</strong>、<strong>文档测试</strong>、<strong>源代码测试</strong>、<strong>数据库测试</strong>、<strong>网络测试</strong>以及<strong>性能测试</strong>等。</p>
<h3 id="8-2-6-按质量属性划分"><a href="#8-2-6-按质量属性划分" class="headerlink" title="8.2.6 按质量属性划分"></a>8.2.6 按质量属性划分</h3><p>按照质量属性划分，软件测试可分为<strong>容错性测试</strong>、<strong>可靠性测试</strong>、<strong>兼容性测试</strong>、<strong>维护性测试</strong>、<strong>安全性测试</strong>和<strong>可移植性测试</strong>。</p>
<h3 id="8-2-7-按测试地域划分"><a href="#8-2-7-按测试地域划分" class="headerlink" title="8.2.7 按测试地域划分"></a>8.2.7 按测试地域划分</h3><p>按照测试地域划分，软件测试可分为<strong>本地化测试</strong>与<strong>国际化测试</strong>两类。</p>
<h2 id="8-3-常用软件测试技术"><a href="#8-3-常用软件测试技术" class="headerlink" title="8.3 常用软件测试技术"></a>8.3 常用软件测试技术</h2><p>常用的软件测试技术主要有<strong>黑盒测试法</strong>与<strong>白盒测试法</strong>。</p>
<h3 id="8-3-1-黑盒测试法"><a href="#8-3-1-黑盒测试法" class="headerlink" title="8.3.1 黑盒测试法"></a>8.3.1 黑盒测试法</h3><p>黑盒测试的测试用例设计方法主要有<strong>测试区域确定法</strong>、<strong>组合覆盖法</strong>、<strong>逻辑推断法</strong>、<strong>业务路径覆盖法</strong>等。</p>
<ol>
<li><p><strong>测试区域确定法</strong></p>
<p>测试区域确定法分为<strong>等价类划分法</strong>与<strong>边界值分析法</strong>。</p>
</li>
<li><p><strong>组合覆盖法</strong></p>
<p>根据覆盖程度不同，组合覆盖法可分为<strong>全组合覆盖法</strong>、<strong>成对组合覆盖法</strong>以及<strong>正交实验设计法</strong>三类。</p>
</li>
<li><p><strong>逻辑推断法</strong></p>
<p>逻辑推断法分为<strong>因果图法</strong>、<strong>判定表法</strong>和<strong>大纲法</strong>等。</p>
</li>
<li><p><strong>业务路径覆盖法</strong></p>
<p>业务路径覆盖法主要分为<strong>场景分析法</strong>和<strong>功能图法</strong>。</p>
</li>
</ol>
<h3 id="8-3-2-白盒测试法"><a href="#8-3-2-白盒测试法" class="headerlink" title="8.3.2 白盒测试法"></a>8.3.2 白盒测试法</h3><p>白盒测试（ White-box Testing ），又称为透明盒测试、结构测试、基于代码的测试或者逻辑驱动测试，主要分为<strong>静态白盒测试</strong>、<strong>动态白盒测试</strong>与<strong>其他白盒测试</strong>三种。</p>
<p>白盒测试是一种测试用例设计方法，盒子是指被测试的软件，白盒是指清楚盒子内部的代码、注释以及看到内部的运作情况。</p>
<p>白盒测试法需要全面了解程序的内部逻辑结构，对所有的逻辑路径进行测试，是一种典型的穷举路径测试。在使用白盒测试时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。</p>
<p>白盒测试常用的工具：内存泄漏检查工具、性能测试工具以及代码覆盖率检查工具。采用白盒测试法需遵循以下原则。</p>
<ol>
<li><p>确保一个模块中的所有独立路径至少被测试一次。</p>
</li>
<li><p>所有逻辑值均需测试真和假两种情况。</p>
</li>
<li><p>检查程序的内部数据结构，确保其结构的有效性。</p>
</li>
<li><p>必须在上、下边界及可操作范围内运行所有循环。</p>
</li>
<li><p><strong>静态白盒测试法</strong></p>
<p>静态白盒测试法是在不执行代码的前提条件下，有条理地审查软件设计、体系结构与代码，从而找出软件缺陷的过程。</p>
<p>其优点是能尽早发现软件缺陷，为黑盒测试人员进行测试时设计测试用例提供思路。静态白盒测试主要有以下三种技术：</p>
<ol>
<li>代码检查法。</li>
<li>静态结构分析法。</li>
<li>静态质量度量法。</li>
</ol>
</li>
<li><p><strong>动态白盒测试法</strong></p>
<p>动态白盒测试又称为结构测试，是指利用查看代码功能与实现方式所得到的信息来确定需要或者不需要测试的内容，以及开展测试的方式。</p>
<p>软件测试人员可根据查看并使用代码的内部结构，进而设计与执行测试。</p>
<p>动态白盒测试不仅要查看代码，还要查看直接参数与控制软件，主要包括以下四个部分。</p>
<ol>
<li>直接测试底层的功能、过程、子程序以及库，即应用程序接口（ API ）。</li>
<li>以完整的程序方式从顶层来测试软件，但要根据对软件运行的了解调整测试案例。</li>
<li>从软件获得读取变量与状态信息的访问权，以便确定测试与预期结果是否相符，与此同时，还要强制软件以正常测试难以实现的方式运行。</li>
<li>估算执行测试时”命中”的代码量与具体代码，然后调整测试，去掉多余的，补充遗漏的。</li>
</ol>
<p>动态白盒测试主要有以下三种技术：</p>
<ol>
<li>覆盖测试。</li>
<li>控制结构测试。</li>
<li>循环测试。</li>
</ol>
</li>
<li><p><strong>其他白盒测试法</strong></p>
<ol>
<li>程序插桩。</li>
<li>程序变异测试。</li>
</ol>
</li>
</ol>
<hr>
<p><a href="https://georgedi.top/posts/a0090000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>经济学</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 Java 语言概述</title>
    <url>/posts/c0010001.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。</p>
<p>由 James Gosling 和同事们共同研发，并在 1995 年正式推出。</p>
<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>
<p>Java分为三个体系：</p>
<ul>
<li>JavaSE（J2SE）（Java2 Platform Standard Edition，Java 平台标准版）</li>
<li>JavaEE（J2EE）（Java 2 Platform，Enterprise Edition，Java 平台企业版）</li>
<li>JavaME（J2ME）（Java 2 Platform Micro Edition，Java 平台微型版）</li>
</ul>
<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 JavaSE 6。</p>
<p>此时，Java 的各种版本已经更名，取消数字 “2”：</p>
<ul>
<li>J2EE 更名为 JavaEE</li>
<li>J2SE 更名为 JavaSE</li>
<li>J2ME 更名为 JavaME</li>
</ul>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li><p>Java 语言是<strong>简单的</strong>：</p>
<p>Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。</p>
<p>另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。</p>
<p>特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。</p>
</li>
<li><p>Java 语言是<strong>面向对象的</strong>：</p>
<p>Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。</p>
<p>Java 语言全面支持动态绑定，而 C++ 语言只对虚函数使用动态绑定。</p>
<p>总之，Java 语言是一个纯的面向对象程序设计语言。</p>
</li>
<li><p>Java语言是<strong>分布式的</strong>：</p>
<p>Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。</p>
<p>Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>
</li>
<li><p>Java 语言是<strong>健壮的</strong>：</p>
<p>Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。</p>
<p>Java 的安全检查机制使得 Java 更具健壮性。</p>
</li>
<li><p>Java 语言是<strong>安全的</strong>：</p>
<p>Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了 Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</p>
</li>
<li><p>Java 语言是<strong>体系结构中立的</strong>：</p>
<p>Java 程序（后缀为 .java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 .class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。</p>
<p>这种途径适合于异构的网络环境和软件的分发。</p>
</li>
<li><p>Java 语言是<strong>可移植的</strong>：</p>
<p>这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。</p>
<p>Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。</p>
</li>
<li><p>Java 语言是<strong>解释型的</strong>：</p>
<p>如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。</p>
<p>在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
</li>
<li><p>Java 是<strong>高性能的</strong>：</p>
<p>与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT（Just-In-Time）编译器技术的发展越来越接近于 C++。</p>
</li>
<li><p>Java 语言是<strong>多线程的</strong>：</p>
<p>在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread（Runnable）的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。</p>
</li>
<li><p>Java 语言是<strong>动态的</strong>：</p>
<p>Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p>
</li>
</ul>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><ul>
<li>1995 年 5 月 23 日，Java 语言诞生</li>
<li>1996 年 1 月，第一个 JDK-JDK1.0 诞生</li>
<li>1996 年 4 月，10 个最主要的操作系统供应商申明将在其产品中嵌入 Java 技术</li>
<li>1996 年 9 月，约 8.3 万个网页应用了 Java 技术来制作</li>
<li>1997 年 2 月 18 日，JDK1.1 发布</li>
<li>1997 年 4 月 2 日，JavaOne 会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li>
<li>1997 年 9 月，JavaDeveloperConnection 社区成员超过十万</li>
<li>1998 年 2 月，JDK1.1 被下载超过 2,000,000 次</li>
<li>1998 年 12 月 8 日，Java2 企业平台 J2EE 发布</li>
<li>1999 年 6 月，SUN 公司发布 Java 的三个版本：JavaSE、JavaEE 和 JavaME</li>
<li>2000 年 5 月 8 日，JDK1.3 发布</li>
<li>2000 年 5 月 29 日，JDK1.4 发布</li>
<li>2001 年 6 月 5 日，NOKIA 宣布，到 2003 年将出售 1 亿部支持 Java 的手机</li>
<li>2001 年 9 月 24 日，J2EE1.3 发布</li>
<li>2002 年 2 月 26 日，J2SE1.4 发布，自此 Java 的计算能力有了大幅提升</li>
<li>2004 年 9 月 30 日，J2SE1.5 发布，成为 Java 语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5 更名为 JavaSE 5.0</li>
<li>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 JavaSE 6。此时，Java 的各种版本已经更名，取消数字 “2”</li>
<li>2006 年 12 月，SUN 公司发布 JRE6.0</li>
<li><strong>2009 年 4 月 20 日，甲骨文 74 亿美元收购 Sun，取得 Java 的版权</strong></li>
<li>2010 年 11 月，由于甲骨文对于 Java 社区的不友善，因此 Apache 扬言将退出 JCP</li>
<li>2011 年 7 月 28 日，甲骨文发布 Java7.0 的正式版</li>
<li>2014 年 3 月 18 日，Oracle 公司发表 JavaSE 8</li>
<li>2017 年 9 月 21 日，Oracle 公司发表 JavaSE 9</li>
<li>2018 年 3 月 21 日，Oracle 公司发表 JavaSE 10</li>
<li>2018 年 9 月 25 日，JavaSE 11 发布</li>
<li>2019 年 3 月 20 日，JavaSE 12 发布</li>
</ul>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>以下是 Java 代码实现控制台输出“Hello World”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<hr>
<p><a href="https://georgedi.top/posts/c0010000.html">返回目录</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章 变量与运算符</title>
    <url>/posts/c0010002.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。</p>
<p>由 James Gosling 和同事们共同研发，并在 1995 年正式推出。</p>
<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>
<p>Java分为三个体系：</p>
<ul>
<li>JavaSE（J2SE）（Java2 Platform Standard Edition，Java 平台标准版）</li>
<li>JavaEE（J2EE）（Java 2 Platform，Enterprise Edition，Java 平台企业版）</li>
<li>JavaME（J2ME）（Java 2 Platform Micro Edition，Java 平台微型版）</li>
</ul>
<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 JavaSE 6。</p>
<p>此时，Java 的各种版本已经更名，取消数字 “2”：</p>
<ul>
<li>J2EE 更名为 JavaEE</li>
<li>J2SE 更名为 JavaSE</li>
<li>J2ME 更名为 JavaME</li>
</ul>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li><p>Java 语言是<strong>简单的</strong>：</p>
<p>Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。</p>
<p>另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。</p>
<p>特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。</p>
</li>
<li><p>Java 语言是<strong>面向对象的</strong>：</p>
<p>Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。</p>
<p>Java 语言全面支持动态绑定，而 C++ 语言只对虚函数使用动态绑定。</p>
<p>总之，Java 语言是一个纯的面向对象程序设计语言。</p>
</li>
<li><p>Java语言是<strong>分布式的</strong>：</p>
<p>Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。</p>
<p>Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>
</li>
<li><p>Java 语言是<strong>健壮的</strong>：</p>
<p>Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。</p>
<p>Java 的安全检查机制使得 Java 更具健壮性。</p>
</li>
<li><p>Java 语言是<strong>安全的</strong>：</p>
<p>Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了 Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</p>
</li>
<li><p>Java 语言是<strong>体系结构中立的</strong>：</p>
<p>Java 程序（后缀为 .java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 .class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。</p>
<p>这种途径适合于异构的网络环境和软件的分发。</p>
</li>
<li><p>Java 语言是<strong>可移植的</strong>：</p>
<p>这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。</p>
<p>Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。</p>
</li>
<li><p>Java 语言是<strong>解释型的</strong>：</p>
<p>如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。</p>
<p>在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
</li>
<li><p>Java 是<strong>高性能的</strong>：</p>
<p>与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT（Just-In-Time）编译器技术的发展越来越接近于 C++。</p>
</li>
<li><p>Java 语言是<strong>多线程的</strong>：</p>
<p>在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread（Runnable）的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。</p>
</li>
<li><p>Java 语言是<strong>动态的</strong>：</p>
<p>Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p>
</li>
</ul>
<h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><ul>
<li>1995 年 5 月 23 日，Java 语言诞生</li>
<li>1996 年 1 月，第一个 JDK-JDK1.0 诞生</li>
<li>1996 年 4 月，10 个最主要的操作系统供应商申明将在其产品中嵌入 JAVA 技术</li>
<li>1996 年 9 月，约 8.3 万个网页应用了 JAVA 技术来制作</li>
<li>1997 年 2 月 18 日，JDK1.1 发布</li>
<li>1997 年 4 月 2 日，JavaOne 会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li>
<li>1997 年 9 月，JavaDeveloperConnection 社区成员超过十万</li>
<li>1998 年 2 月，JDK1.1 被下载超过 2,000,000 次</li>
<li>1998 年 12 月 8 日，JAVA2 企业平台 J2EE 发布</li>
<li>1999 年 6 月，SUN 公司发布 Java 的三个版本：JavaSE、JavaEE 和 JavaME</li>
<li>2000 年 5 月 8 日，JDK1.3 发布</li>
<li>2000 年 5 月 29 日，JDK1.4 发布</li>
<li>2001 年 6 月 5 日，NOKIA 宣布，到 2003 年将出售 1 亿部支持 Java 的手机</li>
<li>2001 年 9 月 24 日，J2EE1.3 发布</li>
<li>2002 年 2 月 26 日，J2SE1.4 发布，自此 Java 的计算能力有了大幅提升</li>
<li>2004 年 9 月 30 日，J2SE1.5 发布，成为 Java 语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5 更名为 JavaSE 5.0</li>
<li>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 JavaSE 6。此时，Java 的各种版本已经更名，取消数字 “2”</li>
<li>2006 年 12 月，SUN 公司发布 JRE6.0</li>
<li><strong>2009 年 4 月 20 日，甲骨文 74 亿美元收购 Sun，取得 Java 的版权</strong></li>
<li>2010 年 11 月，由于甲骨文对于 Java 社区的不友善，因此 Apache 扬言将退出 JCP</li>
<li>2011 年 7 月 28 日，甲骨文发布 Java7.0 的正式版</li>
<li>2014 年 3 月 18 日，Oracle 公司发表 JavaSE 8</li>
<li>2017 年 9 月 21 日，Oracle 公司发表 JavaSE 9</li>
<li>2018 年 3 月 21 日，Oracle 公司发表 JavaSE 10</li>
<li>2018 年 9 月 25 日，JavaSE 11 发布</li>
<li>2019 年 3 月 20 日，JavaSE 12 发布</li>
</ul>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>以下是 Java 代码实现控制台输出“Hello World”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
